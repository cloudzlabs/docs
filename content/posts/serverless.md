---
date: "2018-03-20T13:37:00+09:00"
title: "Serverless"
authors: ["1000jaeh"]
series: []
categories:
  - posts
tags:
  - serverless
  - faas
  - event-driven
  - lambda
  - reactive
cover:
  image: ""
  caption: ""
description: ""
draft: true
---
## 서버리스 컴퓨팅이란

서버리스 컴퓨팅(serverless computing)은 클라우드 컴퓨팅 실행 모델의 하나로, 클라우드 제공자는 동적으로 머신 자원의 할당을 관리한다. 가격은 미리 구매한 용적 단위가 아닌 애플리케이션이 소비한 자원의 실제 양에 기반을 둔다.[1] 유틸리티 컴퓨팅의 일종이다.

서버리스 컴퓨팅은 여전히 서버가 필요하므로 부적절한 명칭이다.[1] "서버리스 컴퓨팅"이라는 이름이 사용된 이유는 서버 관리 및 용적 계획 결정이 완전히 개발자나 운영자로부터 숨겨져 있기 때문이다. 서버리스 코드는 마이크로서비스처럼 전통적인 스타일로 배치(deploy)된 코드와 결합하여 사용할 수 있다. 대안으로, 애플리케이션들은 순수 서버리스 형태로 작성할 수 있으며 프로비전된 서버를 아예 사용하지 않는다.[2]

## 서버리스 프레임워크

서버리스 프레임워크들은 서버리스 애플리케이션을 더 쉽게 빌드, 테스트, 디플로이할 수 있도록 설계된다. 일부 저명한 것들은 다음과 같다:

서버리스 프레임워크
Kubeless
Fission
Funktion
Nuclio
OpenFaas
Oracle Fn

## 개요

서버리스 아키텍처는 써드 파티 서비스 (Backend as a service 또는 "BaaS"로 인식 함) 또는 일시적인 컨테이너 (function as a service 또는 "FaaS")에서 실행되는 사용자 정의된 코드에 크게 의존하는 응용프로그램을 가리키며, 가장 잘 알려진 벤더 호스트는 현재 AWS Lambda입니다. 이러한 아이디어를 사용하고, 많은 행동들이 프런트 엔드로 옮김으로써, 이러한 아키텍처는 응용 프로그램 뒤에 앉아있는 '항상 켜져있는'서버 시스템에 대한 필요성을 없애줍니다. 상황에 따라, 이러한 시스템은 공급 업체에 대한 종속성 및 지원 서비스에 대한 미성숙에 대한 운영 비용과 복잡성을 크게 줄일 수 있습니다.

Serverless는 소프트웨어 아키텍처 세계에서 가장 뜨거운 주제입니다. 우리는 이미 책, 오픈 소스 프레임 워크, 많은 공급 업체 제품, 심지어 주제로 개최되는 컨퍼런스까지보고 있습니다. 하지만 Serverless는 무엇이며 왜 고려 가치가 있습니까? 이 진화하는 출판물을 통해 나는이 질문들에 대해 당신에게 약간의 계몽을하기를 희망합니다.

우선 우리는 접근 방식의 장점과 단점에 대해 중립성을 유지하려고 노력하는 Serverless의 '무엇'을 살펴볼 것입니다. 나중에이 주제들을 살펴 보겠습니다.

## What is Serverless?

소프트웨어의 많은 트렌드와 마찬가지로 '서버리스'가 무엇인지에 대한 명확한 관점은 없으며, 실제로 도움이 되지 않는 2가지 의미가 다가오지만, 중복되는 영역이 있습니다.:

1. Serverless는 처음에는 서버 측의 로직 및 상태를 관리하기 위해 3rd 파티 응용프로그램/서비스(클라우드에 있는..)에 상당히 또는 완전히 의존하는 응용 프로그램을 설명하는 데 사용되었습니다. 이들은 일반적으로 Parse, Firebase와 같은 클라우드 액세스 가능한 데이터베이스의 광대 한생태계, 인증 서비스 (Auth0, AWS Cognito) 등을 사용하는 '리치 클라이언트'응용 프로그램 (단일 페이지 웹 응용 프로그램 또는 모바일 응용 프로그램)입니다. 이러한 유형의 서비스 이전에 '(모바일) Backend as a Service'로 설명했으며, 이 기사의 나머지 부분에서 'BaaS'를 약식으로 사용하게 될 것입니다.

2. Serverless는 응용 프로그램 개발자가 일부 서버 측 로직을 여전히 작성한 응용 프로그램을 의미 할 수도 있지만, 기존 전통적인 아키텍처와 달리 이벤트가 트리거되고, 일시적이며(한 번의 호출에 대해서만 지속될 수 있음), 3rd 파티에서 완전히 관리되는 무상태 저장 컴퓨팅 컨테이너에서 실행됩니다. 이것을 생각하는 한 가지 방법은 'Functions as a Service / FaaS'입니다. AWS Lambda는 현재 FaaS에서 가장 널리 사용되는 구현 중 하나이지만 다른 것들도 있습니다. 나는 이 기사의 나머지 부분에서 Serverless의 의미에 대한 약식으로 'FaaS'를 사용할 것이다. 

대부분이 두 번째 영역에 대해 이야기 할 것입니다. 왜냐하면 이 영역은 최신 기술이며 일반적으로 기술 아키텍처에 대해 생각하는 방식과 큰 차이가 있으며, Serverless를 중심으로 많은 선전을 이끌었습니다. 그러나 이러한 개념은 실제로 관련되어 있으며 사실 수렴하고 있습니다. 좋은 예가 Auth0입니다. 처음에는 BaaS 'Authentication as a Service'으로 시작했지만, Auth0 웹태스크는 FaaS 공간으로 들어간 것입니다.

또한 'BaaS 모양의'애플리케이션을 개발할 때, 특히 모바일 앱과 달리 'rich'웹 기반 앱을 개발할 때, 많은 경우 맞춤 서버 측 functionality가 어느 정도 필요합니다. FaaS function들은 특히 BaaS 서비스와 어느 정도 통합되어 있다면 좋은 해결책이 될 수 있습니다.  이러한 기능의 예로는 데이터 유효성 검사 (임포스터 클라이언트로부터 보호) 및 연산 집약적 처리 (예 : 이미지 또는 비디오 조작)가 있습니다.

## A couple of examples

### UI-driven applications

서버 측 로직을 사용하는 전통적인 3 계층 클라이언트 지향 시스템에 대해 생각해 봅시다. 좋은 예가 전형적인 전자 상거래 앱입니다 (감히 내가 온라인 애완 동물 상점이라고 말합니까?)

전통적으로 아키텍처는 다음과 같이 보일 것이고, 클라이언트 측 HTML / Javascript 구성 요소를 사용하여 서버 측 Java에서 구현되었다고 가정해 봅니다.

![traditional](https://martinfowler.com/articles/serverless/ps.svg)

이 아키텍처를 사용하면 클라이언트는 서버 애플리케이션이 구현하는 인증, 페이지 탐색, 검색, 트랜잭션과 같은 시스템의 많은 로직을 사용하여 비교적 지능적이지 못합니다.

Serverless 아키텍처를 사용하면 이렇게 될 수 있습니다.

![serverless](https://martinfowler.com/articles/serverless/sps.svg)

이것은 대단히 단순화 된 견해이지만, 여기에서도 많은 변화가 있었습니다. 이는 아키텍처 마이그레이션의 권장 사항이 아니므로 일부 서버리스 개념을 폭넓게 드러내는 도구로 사용하고 있습니다.

1. 원래 응용 프로그램의 인증 로직을 삭제하고 3rd파티 BaaS 서비스로 대체했습니다.
2. BaaS의 또 다른 예를 사용하면, 클라이언트가 데이터베이스의 하위 집합(상품목록용)에 직접 액세스 할 수 있게 되었습니다. 해당 데이터베이스 자체는 3rd파티 호스트됩니다(예를들어, AWS Dynamo). 이러한 방식으로 데이터베이스에 액세스 할 수있는 서버 리소스에서 데이터베이스에 액세스하는 클라이언트의 보안 프로필이 다를 수 있습니다.
3. 앞의 두 가지 사항은 매우 중요한 세 번째를 의미합니다. - Pet Store 서버에 있던 일부 로직이 이제 클라이언트 내에 있습니다. 사용자 세션 추적, 응용 프로그램의 UX 구조 이해(예를들어, page navigation), 데이터베이스 읽기 및 유용한 뷰로 변환 등이 포함됩니다. 클라이언트는 실제로 단일 페이지 응용 프로그램이 되는 과정에 있습니다.
4. 일부 UX 관련 기능 예를들어, 집중적 인 계산이거나 상당한 양의 데이터에 대한 액세스가 필요한 경우를 서버에 유지하려고 할 수 있습니다. 예를 들면 '검색'입니다. 항상 실행 중인 서버가 아닌 검색 기능을 위해 우리는 API 게이트웨이를 통해 HTTP 요청에 응답하는 FaaS 기능을 구현할 수 있습니다. 우리는 클라이언트와 서버 기능 모두, 제품 데이터를 위한 동일한 데이터베이스에서 읽을 수 있습니다. 원래 서버는 Java로 구현되었으며, AWS Lambda(이 경우 선택 가능한 FaaS 공급 업체)는 Java로 구현된 기능을 지원하므로, 완전히 다시 쓰지 않아도 Pet Store 서버에서 Pet Store Search 기능으로 검색 코드를 이식 할 수 있습니다.
5. 마지막으로 우리는 '구매'기능을 클라이언트에서 다시 구현하지 않고 보안상의 이유로 서버 측에 유지하면서 다른 FaaS 기능으로 대체 할 수 있습니다. 또한 API 게이트웨이가 앞장서고 있습니다.

### Message-driven applications

다른 예로 백엔드 데이터 처리 서비스가 있습니다. UI 요청에 신속하게 응답해야하는 사용자 중심의 응용 프로그램을 작성중이지만, 2차적으로 발생하는 모든 유형의 활동을 모두 캡처하려고 한다고 가정 해보십시오. 온라인 광고 시스템에 대해 생각해 봅시다. - 사용자가 광고를 클릭하면 광고 대상으로 신속하게 리디렉션 할 수 있지만, 동시에 클릭이 발생했으므로 광고주에 청구할 수 있도록 fact를 수집해야 합니다. (이 예는 가설이 아닙니다. Intent Media의 전직 팀이 최근이 정확하게 재설계를 진행했습니다.)

전통적으로, 아키텍처는 이와 같이 보일 수 있습니다. '광고 서버'는 사용자에게 동기식으로 응답하지만, - 우리는이 예를 위해서 그 상호 작용에 관심이 없다.- 데이터베이스에 업데이트하는 '클릭 프로세서'응용 프로그램에서 비동기식으로 처리 할 수있는 메시지를 채널에 게시합니다. 예를 들어, 광고주의 예산을 줄이려면....

![message-driven-1](https://martinfowler.com/articles/serverless/cp.svg)

Serverless 세계에서 이것은 다음과 같습니다:

![message-driven-2](https://martinfowler.com/articles/serverless/scp.svg)

첫 번째 예제와 비교할 때 아키텍처에 대한 차이점은 훨씬 적습니다. 우리는 수명이 긴 소비자 애플리케이션을 공급 업체가 제공하는 이벤트 중심 컨텍스트 내에서 실행되는 FaaS 기능으로 대체했습니다. 공급 업체는 Message Broker와 FaaS 환경을 모두 제공합니다. 두 시스템은 서로 밀접하게 연결되어 있습니다.

FaaS 환경은 기능 코드의 여러 복사본을 인스턴스화하여 여러 번의 클릭을 동시에 처리 할 수 ​​있습니다. - 원래 프로세스를 작성한 방법에 따라 고려해야 할 새로운 개념일 수 있습니다.

### Unpacking 'Function as a Service'

우리는 이미 FaaS 아이디어를 많이 언급했지만, 실제로 그것이 의미하는 바를 파헤 칠 때가되었습니다. 이를 위해 Amazon의 Lambda 제품에 대한 개시 설명을 살펴 보겠습니다. 몇 가지 토큰을 추가했습니다.

> AWS Lambda를 사용하면 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있습니다. (1) ... Lambda를 사용하면, 사실상 모든 유형의 응용 프로그램 또는 백엔드 서비스 (2)에 대한 코드를 실행할 수 있습니다. 코드를 업로드하기 만하면 Lambda가 고 가용성으로 코드를 실행 (3)하고 확장 (4)하는 데 필요한 모든 작업을 처리합니다. 다른 AWS 서비스 (5)에서 자동으로 트리거하거나 웹 또는 모바일 앱 (6)에서 직접 호출하도록 코드를 설정할 수 있습니다.

AWS Lambda를 사용하면 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있습니다. (1) ... Lambda를 사용하면, 사실상 모든 유형의 응용 프로그램 또는 백엔드 서비스에 대한 코드를 실행할 수 있습니다. (2) 코드를 업로드하면 Lambda가 고 가용성으로 코드를 실행하고(3)  확장하는데 (4) 필요한 모든 것을 처리합니다. 다른 AWS 서비스에서 자동으로 트리거하거나 (5) 웹 또는 모바일 앱에서 직접 호출하도록 코드를 설정할 수 있습니다 (6).

1. 근본적으로 FaaS는 자체 서버 시스템 또는 자체 서버 응용 프로그램을 관리하지 않고 백엔드 코드를 실행하는 것입니다. 두 번째 조항은 - 서버 응용 프로그램 - 컨테이너 및 PaaS (Platform as a Service)와 같은 다른 현대 구조적인 트렌드와 비교할 때 중요한 차이점입니다. FaaS가 수행하는 이전의 클릭 처리 예제로 돌아 가면 클릭 처리 서버(실제 시스템이지만 확실히 특정 애플리케이션)를 프로비저닝 된 서버나 항상 실행중인 응용 프로그램이 필요없는 것으로 대체합니다.

2. FaaS 오퍼링은 특정 프레임 워크 또는 라이브러리에 코딩 할 필요가 없습니다. FaaS 기능은 언어 및 환경과 관련하여 일반적인 응용 프로그램입니다. 예를 들어 AWS Lambda 함수는 Javascript, Python 및 JVM 언어(Java, Clojure, Scala, etc.)에서 'first class'로 구현 될 수 있습니다. 그러나 람다 함수는 배포 아티팩트에 번들 된 다른 프로세스를 실행할 수 있으므로, 실제로 유닉스 프로세스로 컴파일 할 수 있는 언어를 사용할 수 있습니다(나중에 Apex를 참조하십시오). FaaS 함수는 특히 상태 및 실행시간과 관련하여 중요한 아키텍처 제한이 있으며 곧 이에 관해서 설명 할 것입니다. 클릭 처리의 예를 다시 생각해 봅시다. - FaaS로 이동할 때 변경해야하는 유일한 코드는 '기본 메소드 / 시작'코드입니다. 이 코드는 삭제되고 최상위 메시지 핸들러 인 특정 코드(예 : 'message listener interface'구현)일 가능성이 있지만, 이것은 메소드 시그니처의 변경 일 수 있습니다. 나머지 코드 (예 : 데이터베이스에 쓰는 코드)는 모두 FaaS 세계에서 다를 수 있습니다.

3. 배포를 실행할 서버 응용 프로그램이 없으므로 기존 시스템과 매우 다릅니다. - 우리는 FaaS 제공자에게 코드를 업로드하면 그게 다 입니다. 지금은 일반적으로 코드 정의 (예 : zip 또는 JAR 파일)를 업로드 한 다음, 독점 API를 호출하여 업데이트를 시작하는 것을 의미합니다.

4. 수평적 확장은 완전히 자동이고 탄력적이며 공급자가 관리합니다. 만약 시스템에서 100 개의 요청을 병렬로 처리해야하는 경우, 공급자는 사용자가 추가 구성을하지 않아도이를 처리합니다. 함수를 실행하는 '계산 컨테이너'는 FaaS 제공자가 순전히 런타임 필요에 의해 유도 된 프로비저닝 및 파기와 함께 일시적입니다. 클릭 프로세서로 돌아 갑시다. 우리가 좋은 하루 보내고 고객이 평소보다 10 배 많은 광고를 클릭하고 있다고 가정 해보십시오. 클릭 처리 애플리케이션에서 이 문제를 처리 할 수 ​​있습니까? 예를 들어 한 번에 여러 메시지를 처리 ​​할 수 ​​있도록 코딩 했습니까? 우리가 경우라도 응용 프로그램의 인스턴스를 하나만 구동해도 로드를 처리하기에 충분합니까? 여러 프로세스를 실행할 수있는 경우 자동으로 자동 크기 조정이 수행됩니까? 아니면 수동으로 재구성해야합니까? FaaS를 사용하면 병렬 처리를 가정하여 미리 함수를 작성해야하지만, FaaS 제공자의 해당 시점부터 자동으로 모든 확장 요구를 처리합니다.

5. FaaS의 함수는 공급자가 정의한 이벤트 유형에 의해 트리거됩니다. Amazon AWS와 같은 이러한 자극에는 S3 (파일) 업데이트, 시간 (scheduled tasks) 및 메시지가 메시지 버스에 추가됩니다(예. Kinesis). 함수는 일반적으로 연결된 이벤트 소스와 관련된 매개 변수를 제공해야합니다. 클릭 프로세서를 통해 우리는 이미 FaaS - 메시지브로커를 지원하는 - 를 사용하고 있다는 가정을했습니다. 그렇지 않으면 우리는 메시지 프로듀서로 변경해야 할 필요가 있었습니다.

6. 또한 대부분의 공급자는 일반적으로 일종의 API 게이트웨이에서 인바운드 HTTP 요청에 대한 응답으로 함수를 트리거 할 수 있습니다. (예 : AWS API 게이트웨이, 웹 태스크). 우리는 Pet Store 예제에서 '검색'및 '구매'기능을 사용했습니다.

### State

FaaS 함수는 로컬 (기계 / 인스턴스 바운드) 상태 일 때 상당한 제한이 있습니다. 즉, 주어진 함수 호출에 대해 작성한 프로세스 또는 호스트 상태가 후속 호출에 사용 가능하지 않다고 가정해야 합니다. (In short you should assume that for any given invocation of a function none of the in-process or host state that you create will be available to any subsequent invocation. ) 여기에는 RAM의 상태와 로컬 디스크에 기록 할 수있는 상태가 포함됩니다. 즉, 배포 단위 관점에서 FaaS 함수는 stateless입니다.

이는 독특한 아키텍처는 아니지만 애플리케이션 아키텍처에 엄청난 영향을 미칩니다. '12 요소 애플리케이션'개념에는 똑같은 제한이 있습니다.

이 제한을 감안할 때 대안은 무엇입니까? 일반적으로 FaaS 함수는 자연스럽게 상태를 갖지 않거나 - 즉 입력값에 대한 순수한 함수 변환을 제공 -, 요청을 가로 지르는 상태를 저장하거나 요청을 처리하기 위한 추가 입력을 위해 데이터베이스, 교차 애플리케이션 캐시 (예 : Redis) 또는 네트워크 파일 저장소 (예 : S3)를 사용합니다. .

### Excution Duration

FaaS 함수는 일반적으로 각 호출을 실행할 수있는 시간이 제한되어 있습니다. 현재 AWS 람다 함수는 5 분 이상 실행될 수 없으며 종료되면 종료됩니다.

이것은 오래 살아있는 태스크의 특정 클래스가 리아키텍쳐 없이는 FaaS 기능에 적합하지 않다는 것을 의미합니다. 예를들어, 전통적인 환경에서 조정과 실행을 모두 수행하는 하나의 장기간 task를 몇 가지 서로 다른 조정 된 FaaS 기능으로 쪼개서 만들어야 할 수도 있습니다.

### Startup Latency

현재 FaaS 기능이 요청에 응답하는 데 걸리는 시간은 많은 요인에 따라 달라지며 10ms에서 2 분 정도 소요될 수 있습니다. 

AWS Lambda를 예로 들어 좀 더 구체적으로 살펴 보도록하겠습니다. 함수가 Javascript 또는 Python으로 구현되고, 크지 않은(즉, 1000 줄 미만의 코드) 경우에는 실행하는 데 오버 헤드가 10-100 ms를 초과해서는 안됩니다. 더 큰 함수는 때때로 더 긴 시간을 볼 수 있습니다.

람다 함수가 JVM에 구현 된 경우 JVM이 회전되는 동안 가끔 응답 시간이 길어질 수 있습니다 (예 : 10 초 초과). 그러나 이는 다음 시나리오 중 하나에서만 발생합니다.

- 함수는 호출 간 간격이 10 분을 초과하지 않도록 이벤트를 자주 처리하지 않습니다.
- 트래픽이 급격히 증가합니다. 예를 들어 일반적으로 초당 10 개의 요청을 처리하지만 10 초 이내에 초당 최대 100 개의 요청을 처리합니다.

이 중 전자는 특정 상황에서 5 분마다 기능을 핑핑 (pinging)하는 추악한 해킹으로 피할 수 있습니다.

이러한 문제가 우려됩니까? 응용 프로그램의 스타일과 트래픽 모양에 따라 다릅니다. 저의 전 팀은 자바로 구현 된 비동기식 메시지 처리 람다 (Lambda) 애플리케이션을 가지고 있습니다. 이 애플리케이션은 하루에 수억 개의 메시지를 처리하며, 시작시의 대기 시간에는 관심이 없습니다. 저 지연 응용 프로그램을 작성하는 경우, 구현시 사용하는 언어와 상관없이 현재 FaaS 시스템을 사용하고 싶지 않을 것입니다.

앱에 이와 같은 문제가 발생할 수도 있다고 생각하든 그렇지 않든간에 프로덕션과 같은 로드로 테스트하여 어떤 성능을 확인해야합니다. 유스 케이스가 작동하지 않는 경우 FaaS 벤더가 개발하는 주요 영역이기 때문에 몇 달 이내에 다시 시도 할 수 있습니다.

### API Gateway

![apigateway](https://martinfowler.com/articles/serverless/ag.svg)

이전에 닦았 던 FaaS의 한 측면은 'API 게이트웨이'입니다. API 게이트웨이는 라우트 / 엔드 포인트가 구성에서 정의되고 각 라우트가 FaaS 기능과 연관되는 HTTP 서버입니다. API 게이트웨이는 요청을 받으면 요청과 일치하는 라우팅 구성을 찾은 다음 관련 FaaS 기능을 호출합니다. 일반적으로 API 게이트웨이는 http 요청 매개 변수에서 FaaS 기능에 대한 인수를 입력하도록 허용합니다. API 게이트웨이는 FaaS 함수 호출의 결과를 http 응답으로 변환하고 이를 원래 호출자에게 리턴합니다.

Amazon Web Services에는 자체 API 게이트웨이가 있으며 다른 공급 업체에서도 유사한 기능을 제공합니다.

순전히 라우팅 요청을 넘어 API 게이트웨이는 인증, 입력 유효성 검사, 응답 코드 매핑 등을 수행 할 수도 있습니다. 당신의 Spidey-sense는 실제로 이것이 좋은 아이디어인지 아닌지에 대해 윙윙 거리고 있습니다. - 우리는 나중에 이것을 더 고려할 것입니다.

API Gateway + FaaS의 한 가지 사용 사례는 FaaS 기능에서 비롯된 모든 확장, 관리 및 기타 이점을 사용하여 서버가없는 방식으로 http 기반 마이크로 서비스를 만드는 것입니다.

현재 API 게이트웨이를위한 툴링은 미숙하고 API 게이트웨이가있는 어플리케이션을 정의하는 것이 가능하지만 그것은 미미한 정도입니다.(At present tooling for API gateways is achingly immature and so while defining applications with API gateways is possible it’s most definitely not for the faint-hearted)

### Tooling

실제로 적용하기에 미성숙한 API 게이트웨이 툴링에 관한 위의 코멘트는, 전체적으로, Serverless FaaS에 일반적으로 적용됩니다. 그러나 예외가 있습니다. - 한 가지 예가 Auth0 Webtask이며, 이는 툴링에서 Developer UX에 우선 순위를 둡니다. Tomasz Janczuk은 최근 Serverless Conference에서 이것을 잘 보여주었습니다.

디버깅 및 모니터링은 일반적으로 Serverless 애플리케이션에서 까다로울 수 있습니다.이 기사의 후속 기사에서 더 자세히 살펴 보겠습니다.

### Open Source

Serverless FaaS 애플리케이션의 주요 이점 중 하나는 투명한 프로덕션 런타임 프로비저닝이며, 오픈 소스는 현재 Docker 및 컨테이너로 불리는 세상과 관련이 없습니다. 앞으로는 온 프레미스 (on premise) 또는 개발자 워크 스테이션에서 실행될 인기있는 FaaS / API 게이트웨이 플랫폼 구현을 보게 될 것입니다. IBM의 OpenWhisk는 이러한 구현의 예이며 이 구현 또는 대안 구현이 채택 여부를 결정하는 것이 흥미로울 것입니다.

런타임 구현과는 별도로 이미 정의, 배포 및 런타임 지원을 지원하는 오픈 소스 도구 및 프레임 워크가 있습니다. 예를 들어 Serverless Framework는 AWS가 제공하는 첫 번째 원칙을 사용하는 것보다 API Gateway + Lambda를 사용하는 것이 훨씬 쉽습니다. Javascript는 무겁지만 JS API 게이트웨이 애플리케이션을 작성하는 경우 꼭 한 번 볼만한 가치가 있습니다.

또 다른 예는 'AWS Lambda 기능을 손쉽게 구축, 배포 및 관리하는 프로젝트'인 Apex입니다. Apex에서 특히 흥미로운 점 중 하나는 Amazon에서 직접 지원하는 언어 이외의 언어로 람다 함수를 개발할 수 있다는 것입니다. 예를 들어, Go.

## What isn't Serverless?

지금까지이 기사에서 '서버리스'는 '백엔드 서비스'와 '서비스 기능'이라는 두 가지 아이디어의 결합을 의미한다고 정의했습니다. 나는 또한 이들 중 두 번째 기능을 파헤 쳤다.

우리가 장점과 단점 중 가장 중요한 부분을 살펴보기 전에 정의에 대해 더 많은 것을 알기를 원하거나 Serverless가 정의하지 않은 것을 정의하고 싶습니다. 나는 몇몇 사람들 (최근에 나를 포함해서)이 이런 것들에 대해 혼란스러워하며 명확성을 위해 토론 할 가치가 있다고 생각한다.

### Comparison with PaaS

Serverless FaaS 기능이 12-Factor 애플리케이션과 매우 유사하다는 점을 감안할 때 사실 Heroku와 같은 'PaaS (Platform as a Service)'의 또 다른 형태입니까? 간단한 대답은 Adrian Cockcroft를 참조하십시오.

> adrian cockcroft
> @adrianco
> If your PaaS can efficiently start instances in 20ms that run for half a second, then call it serverless.
> 만약 PaaS가 30초에 구동되는 인스턴스를 20ms 안에 효과적으로 기동한다면, 서버리스라 부를 수 있다.

즉, 대부분의 PaaS 응용 프로그램은 모든 요청에 ​​대해 전체 응용 프로그램을 위아래로 가져 오는 방향으로 조정되지 않지만 FaaS 플랫폼은 정확히 이 기능을 수행합니다.

좋아요. 그렇지만 12- 팩터 앱 개발자가 되어도 코드 작성 방법에는 차이가 없습니다. 사실이지만 앱 운영 방식에는 큰 차이가 있습니다. 우리는 모두 개발팀에 익숙한 엔지니어이므로 개발과 관련하여 최대한 많은 작업을 생각하고 있습니다. 그렇죠?

FaaS와 PaaS의 주요 운영상의 차이점은 규모 조정입니다. 대부분의 PaaS에서는 예를 들어, 헤로쿠와 함께 얼마나 많은 Dynos가 기동되길 원합니까와 같은 규모에 대해 생각할 필요가 있습니다. 
FaaS 응용 프로그램을 사용하면 이것이 완전히 투명합니다. PaaS 응용 프로그램을 자동 확장하도록 설정해도 개별 요청 수준으로는 수행하지 않으므로(매우 구체적인 트래픽 프로필이없는 한
), FaaS 응용 프로그램은 비용면에서 훨씬 효율적입니다.

이러한 이점이 주어진다면, 왜 PaaS를 사용하겠는가? 몇몇 이유가 있겠지만, API 게이트웨이의 성숙도와 툴링이 가장 큰 이유일 것이다. 또한 PaaS에 구현 된 12 요소 애플리케이션은 최적화를 위해 인앱 읽기 전용 캐시를 사용할 수 있지만, 이는 FaaS 기능을 위한 옵션이 아닙니다.

### Comparison with containers

Serverless FaaS의 이유 중 하나는 운영 체제 수준에서 계산 프로세스를 관리하지 않아도된다는 것입니다. Heroku와 같은 Platform-as-a-Service는 또 다른 하나이며, PaaS가 Serverless FaaS와 다른 점은 위에 설명했습니다. 프로세스의 또 다른 대중적인 추상화는 Docker가 그러한 기술의 가장 보편적 인 예가되는 컨테이너입니다. 또한 OS 레벨 배포에서 개별 응용 프로그램을 추상화하는 Mesos 및 Kubernetes와 같은 컨테이너 호스팅 시스템의 인기가 증가하고 있습니다. 또한 Amazon ECS 및 Google Container Engine과 같은 클라우드 호스팅 컨테이너 플랫폼은 Serverless FaaS와 마찬가지로 자체 서버 시스템을 전혀 관리하지 않아도됩니다. 따라서 컨테이너 주위에 모든 momentum이 주어지면 Serverless FaaS를 고려해 볼 가치가 있습니까?

기본적으로 PaaS에 대한 논쟁은 여전히 ​​컨테이너를 가지고 있습니다. Serverless FaaS 스케일링은 자동으로 관리되고 투명하며 세분화됩니다. 컨테이너 플랫폼은 아직 그러한 솔루션을 제공하지 않습니다.

게다가 저는 지난 몇 년 동안 엄청난 인기를 보았을 때 컨테이너 기술이 아직 성숙하지 않았다고 주장 할 것입니다. Serverless FaaS가 성숙했다는 것을 말하는 것이 아니라, 당신이 원하는 rough edges를 선택하는 것이 여전히 그 순서입니다.(but picking which rough edges you’d like is still the order of the day).

그러나 나는 이 두 주장이 시간이 지남에 따라 얇아지기 시작할 수도 있음을 인정할 것이다. 컨테이너 플랫폼의 관리 기능이 없는 자동 스케일링은 아직 Serverless FaaS 수준이 아니지만 Kubernetes의 Horizontal Pod Autoscaling과 같은 영역을 고려해야합니다. 이러한 기능에 대해 도입된 매우 똑똑한 트래픽 패턴 분석은, 물론 부하 관련 통계를 더 많이 상상할 수 있습니다. 또한 Kubernetes의 급속한 진화는 너무 오래 전에 멋지고 간단하고 안정적인 플랫폼을 제공 할 수 있습니다.

Serverless FaaS와 호스팅 된 컨테이너 사이의 관리 및 확장의 차이가 좁아지면 단지, 이들 사이의 선택이 응용 프로그램의 스타일 및 유형으로 내려갈 수 있습니다. 예를 들어, 응용 프로그램 구성 요소 당 이벤트 유형이 거의없는 이벤트 중심 스타일에 대해 FaaS가 더 나은 선택으로 간주 될 수 있으며, 많은 진입 점이있는 동기 요청 구동 구성 요소의 경우 컨테이너가 더 나은 선택으로 간주 될 수 있습니다. 저는 5년 내에 많은 응용 프로그램과 팀이 아키텍처 접근 방식을 모두 사용할 것으로 기대하며, 그러한 사용 패턴이 나타나는 것이 매력적이게 될 것입니다.

### NoOps

Serverless는 'No Ops'를 의미하지 않습니다. 서버리스 토끼 구멍에서 얼마나 멀리 떨어져 있는지에 따라 '내부 Sys Admin 없음'을 의미 할 수도 있습니다. 여기서 고려해야 할 중요한 두 가지 사항이 있습니다(It might mean ‘No internal Sys Admin’ depending on how far down the serverless rabbit hole you go).

첫째, 'Ops'는 서버 관리 이상의 의미입니다. 또한 적어도 모니터링, 배포, 보안, 네트워킹을 의미하며 때로는 일정량의 프로덕션 디버깅 및 시스템 확장을 의미합니다. 이러한 문제는 모두 Serverless 앱에서 여전히 존재하며 문제를 해결하기위한 전략이 필요합니다. Ops는 서버가없는 세상에서 어떤면에서는 더 힘든 부분이 많습니다.

두 번째로 Sys Admin도 여전히 존재합니다. - Serverless로 아웃소싱하는 것뿐입니다. 이것이 반드시 나쁜 것은 아닙니다. - 우리는 많은 것을 아웃소싱합니다. 하지만 정확히 무엇을하려하는지에 따라 좋은 것이든 나쁜 것이든 간에 어떤 점에서는 추상화가 누출 될 수 있으며 인간의 시스템 관리자가 어딘가에서 애플리케이션을 지원하는지 알아야합니다.

Charity Majors는 최근의 Serverless Conference에서 이 주제에 대해 훌륭한 강의를했으며, 온라인에서 사용 가능 해지면 체크 아웃하는 것이 좋습니다. 그 때까지 [여기](https://charity.wtf/2016/05/31/wtf-is-operations-serverless/)링크와 [여기](https://charity.wtf/2016/05/31/operational-best-practices-serverless/)에서 그녀의 글을 읽을 수 있습니다.

### Stored Procedures as a Service

> Camille Fournier
> @skamille
> I wonder if serverless services will become a thing like stored procedures, a good idea that quickly turns into massive technical debt
> serverless 서비스가 스토어드 프로 시저와 같은 것이 될지 궁금합니다. 훌륭한 아이디어는 빠르게 대량의 기술적 부채로 변합니다.

내가 본 또 다른 테마는 Serverless FaaS가 'Stored Procedures as a Service'라는 것입니다. 필자는 FaaS 함수의 많은 예제 (이 기사에서 사용한 일부 포함)는 데이터베이스에 대한 액세스를 감싸는 작은 코드 조각이라는 사실에서 비롯된 것이라고 생각한다. 그것이 우리가 FaaS를 사용할 수있는 전부라면 그 이름이 유용 할 것이지만 실제로는 FaaS의 능력의 일부분이기 때문에 FaaS에 대한 그런 생각은 잘못된 제약이라는 것입니다.

FaaS가 언급 된 트윗에서 Camille이 언급 한 기술 부채 문제를 포함하여 저장 프로 시저와 동일한 문제가 있는지 여부를 고려해 볼 가치가 있다고합니다. FaaS의 컨텍스트에서 검토 할 가치가있는 저장된 procs를 사용하고 적용 여부를 확인하는 많은 교훈이 있습니다. 이들 중 일부는 저장 프로 시저입니다.

1. 종종 공급 업체별 언어 또는 적어도 공급 업체별 프레임 워크 / 언어 확장 기능이 필요합니다.
2. 데이터베이스 컨텍스트에서 실행해야 하므로 테스트하기가 어렵습니다.
3. 버전 제어 / 처리에 까다로운 first class 애플리케이션으로 취급됩니다.

이것들 모두가 저장된 procs의 모든 구현에 적용되는 것은 아니지만, 분명히 내가 겪어 본 문제점들이다. FaaS에 적용 할 수 있는지 알아 보겠습니다.

(1)은 지금까지 보아 왔던 FaaS 구현에 대한 관심사가 아니므로 지금 바로 목록에서 제거 할 수 있습니다.

(2)에서는 'just code' 단위 테스트를 다루는 것이 다른 코드처럼 쉽습니다. 통합 테스트는 다른 (그리고 합법적인) 질문이지만 나중에 논의 할 것입니다.

(3)에서는 FaaS 함수가 '단순한 코드'이므로 버전 제어가 정상입니다. 그러나 응용 프로그램 패키징과 관련하여 아직 성숙한 패턴이 없습니다. 앞서 언급 한 Serverless 프레임 워크는 자체 양식을 제공하며, AWS는 2016 년 5 월 Serverless 컨퍼런스에서 패키징을위한 무언가 ('Flourish') 작업을하고 있다고 발표했지만 현재로서는 또 다른 정당한 관심사입니다.

## Benefits

지금까지 저는 대부분 Serverless 아키텍처가 의미하는 바를 정의하고 설명하는 데 주로 집중하려고했습니다. 이제는 응용 프로그램을 설계하고 배포하는 것과 같은 몇 가지 이점과 단점에 대해 논의 할 것입니다.

이 기술 중 일부는 매우 새롭다는 사실을 바로 알아 두는 것이 중요합니다. AWS Lambda - 선도적인 FaaS 구현 - 는 글을 작성하는 시점에서 만들어진지 2 년이 안됬습니다. 우리가 느끼는 이점의 일부는 다른 2 년 후에 되돌아 볼 때 과대 광고로 끝날 수 있습니다. 반면에 단점 중 일부는 해결 될 것입니다.

이것은 검증되지 않은 개념이기 때문에 큰 고려 사항없이 Serverless를 사용하기로 결정하지 않아야합니다. 이 장단점 목록이 당신이 그러한 선택에 도움이되기를 바랍니다.

우리는 무지개와 유니콘의 땅에서 시작하여 Serverless의 이점을 살펴볼 것입니다.

### Reduced operational cost

Serverless는 가장 단순한 아웃소싱 솔루션입니다. 그것은 당신이 스스로 관리 할 수도있는 서버, 데이터베이스 그리고 애플리케이션 로직을 관리하기 위해 누군가에게 돈을 지불하는 것을 허용합니다. 다른 많은 사람들도 사용할 수있는 정의 된 서비스를 사용하고 있으므로 규모의 경제 효과를 볼 수 있습니다. 하나의 공급 업체가 수천 개의 매우 유사한 데이터베이스를 실행하기 때문에 관리되는 데이터베이스의 비용을 덜 지불하게됩니다.

비용 절감은 인프라 비용과 사람 (운영 / 개발) 비용이라는 두 가지 측면의 총합으로 나타납니다. 비용 증가의 일부는 다른 사용자와 인프라 (하드웨어, 네트워킹)를 공유함으로써 만 얻을 수 있지만, 아웃소싱 된 서버가없는 사용자는 자신의 시간을 덜 소비하여 운영 비용을 절감해야합니다. 시스템을 개발하고 자체적으로 호스팅하는 것과 동등합니다.

그러나 이 이점은 IaaS (Infrastructure as a Service) 또는 PaaS (Platform as a Service)에서 얻을 수있는 이점과 크게 다르지 않습니다. 그러나 우리는 Serverless BaaS 및 FaaS 각각에 대해 두 가지 주요 방법으로이 이점을 확장 할 수 있습니다.

### BaaS - reduced development cost

IaaS 및 PaaS는 서버 및 운영 체제 관리가 범용화 될 수 있다는 전제에 기반합니다. 반대로 서버없는 백엔드 서비스는 전체 응용 프로그램 구성 요소가 범용화 된 결과입니다.

인증은 좋은 예입니다. 많은 애플리케이션은 가입, 로그인, 비밀번호 관리, 다른 인증 제공 업체와의 통합 등과 같은 기능을 포함하는 자체 인증 기능을 코딩합니다. 전체적으로 이 로직은 대부분의 애플리케이션에서 매우 유사하므로 Auth0과 같은 서비스가 생성되었습니다 우리가 스스로 개발할 필요없이 우리가 준비된 인증 기능을 애플리케이션에 통합 할 수있게 해줍니다.

Firebase의 데이터베이스 서비스와 같은 BaaS 데이터베이스가 동일한 스레드에 있습니다. 일부 모바일 응용 프로그램 팀은 클라이언트가 서버 측 데이터베이스와 직접 통신하게하는 것이 합리적임을 발견했습니다. BaaS 데이터베이스는 많은 데이터베이스 관리 오버 헤드를 없애고 일반적으로 서버리스 (Serverless) 애플리케이션에서 예상되는 패턴으로 다양한 유형의 사용자에게 적절한 승인을 제공하는 메커니즘을 제공합니다.

귀하의 배경에 따라 이러한 아이디어를 모두 엿먹일 수 있습니다(단점이있는 부분에 대해서는 걱정하지 마십시오!) 간신히 자신의 서버 측 코드가 포함 된 강력한 제품을 생산할 수 있었던 성공적인 기업의 수를 부정하는 것은 아닙니다. Joe Emison은 최근의 Serverless Conference에서 두 가지 예를 들었습니다.

### FaaS - scaling costs

serverless FaaS의 즐거움 중 하나는 필자가 이 기사의 앞 부분에서 말했듯이 '수평 확장은 완전히 자동적이고 탄력적이며 공급자가 관리합니다'. 여기에는 몇 가지 이점이 있지만 기본 인프라 측면에서 가장 큰 이점은 AWS Lambda의 경우 100ms 경계까지 필요한 계산에 대해서만 비용을 지불한다는 것입니다. 트래픽 규모와 모양에 따라 이것은 경제적으로 큰 승리 일 수 있습니다.

#### Example - occasional requests

예를 들어 매분 1 회의 요청 만 처리하는 서버 응용 프로그램을 실행 중이며 각 요청을 처리하는 데 50 밀리 초가 걸리며 평균 CPU 사용량은 1 시간 동안 0.1 %라고 가정합니다. 한 가지 관점에서 이것은 비효율적입니다. 1000 개의 다른 응용 프로그램이 CPU를 공유 할 수 있다면 동일한 컴퓨터에서 작업 할 수 있습니다.

Serverless FaaS는 이러한 비효율을 포착하여 비용을 절감하면서 혜택을 제공합니다. 이 시나리오에서는 매분 100ms 만 지불하면되므로 전체 시간의 0.15 %입니다.

이것은 다음과 같은 노크 - 온 이점을 가지고있다 :

- 매우 작은로드 요구 사항을 갖는 마이크로 서비스의 경우, 미세 단위의 운영 비용이 엄청나게 높을지라도 로직 / 도메인별로 구성 요소를 분해하는 지원을 제공합니다.
- 이러한 비용 절감은 훌륭한 민주주의 자입니다. 회사나 팀이 새로운 것을 시험해보고자 할 때, FaaS를 컴퓨팅 요구에 사용할 때 '물속에 발을 살짝 담그는 것'과 같이 관련된 운영 비용이 극히 적습니다. 
- 실제로 전체 워크로드가 상대적으로 작지만 (전체적으로 중요하지 않은 경우) 일부 FaaS 공급 업체가 제공하는 '무료 티어'로 인해 계산에 대한 비용을 전혀 지불하지 않아도됩니다.

#### Example - inconsistent traffic

다른 예를 살펴 보겠습니다. 트래픽 프로필이 매우 '스파이키(spikey)'라고 가정 해보십시오. - 기본 트래픽은 초당 20 요청이지만 5 분마다 초당 200 회의 요청 (보통 수의 10배)을 10 초 동안받습니다. 기본 성능이 원하는 서버를 최대한으로 사용하고 트래픽 스파이크 단계에서 응답 시간을 줄이려하지 않는다고 가정 해 봅시다. 예를 들어 기본 성능이 기본 설정 서버를 최대한으로 사용한고, 트래픽 스파이크 단계에서 응답 시간을 줄이려는 것이 아니라고 가정해봅시다. 어떻게 이것을 해결할 수 있습니까?

일반적인 환경에서는 총 시스템 가동 시간의 4 % 미만 만 차지하더라도 스파이크를 처리하려면 총 하드웨어 용량을 10 배로 늘려야합니다. 새 인스턴스가 부팅 될 때까지 서버의 새로운 인스턴스를 가져 오는 데 걸리는 시간이 길어지기 때문에 자동 크기 조정은 좋은 옵션이 아닙니다.

![spikey](https://martinfowler.com/articles/serverless/inconsistent-traffic-pattern.png)

그러나 Serverless FaaS를 사용하면 이것이 문제가 되지 않습니다. 말 그대로 트래픽 프로필이 일정한 경우와 다르게 스파이크 단계에서 추가 컴퓨팅 용량을 지불하여 처리합니다. 

분명히 Serverless FaaS가 엄청난 비용 절감 효과를 가져다 주었던 점을 분명히 여기에서 골랐지만 요컨대 요즘은 FaaS를 사용하여 돈을 절약 할 수있는 정수의 서버 시스템을 지속적으로 사용하는 트래픽이 일정하지 않으면 스케일링 관점에서.

분명히 Serverless FaaS가 엄청난 비용 절감 효과를 가져다주는 예를 고의로 여기에서 골랐으나, 요점은 일관된 숫자의 서버 시스템을 일관되게 사용하는 매우 안정적인 트래픽 형태에서가 아닌 순전히 스케일링 관점에서 FaaS를 사용하여 비용을 절감 할 수 있다는 것입니다.

위의 사항에 대한 한 가지 주의 사항 - 트래픽이 균일하고 지속적으로 실행중인 서버를 효율적으로 활용한다면 이 비용상의 이점을 볼 수 없으며 실제로 FaaS를 사용하여 더 많은 비용을 지출 할 수 있습니다. 현재 공급 업체 비용과 실행중인 풀 타임 서버의 비용을 비교하여 비용이 수용 가능한지 여부를 확인해야합니다.

#### Optimization is the root of some cost savings(최적화는 비용 절감의 근원입니다.)

FaaS 비용에는 흥미로운 점이 하나 더 있습니다. - 코드에 대한 성능 최적화를 통해 앱의 속도가 향상 될뿐만 아니라 공급 업체의 요금 체계가 세분화되어 운영 비용이 절감 될 수 있습니다. 예를 들어, 각 작업에 현재 1 초가 걸리고 200ms로 줄이면 인프라 변경없이 즉시 컴퓨팅 비용이 80 % 절감됩니다.

### Easier Operational Management(더 쉬운 운영 관리)

이 섹션에는 거대한 별표가 붙습니다. Serverless에서는 아직 몇 가지 작업이 어렵습니다. 그러나 지금은 새로운 유니콘과 레인보우 친구들과 함께하고 있습니다.

울타리의 Serverless BaaS 측면에서 운영 관리가 다른 아키텍처보다 더 단순한 이유는 상당히 분명한 사실입니다. 지원하는 구성 요소가 적어 작업량이 적습니다.

FaaS 측면에는 여러 측면이 있지만 나는 그 중 몇 가지를 파헤칩니다.

#### Scaling benefits of FaaS beyond costs(FaaS의 이점을 비용 이상으로 확장)

이전 섹션에서 스케일링이 새롭지만, FaaS의 스케일링 기능은 컴퓨팅 비용을 줄여 줄뿐만 아니라 스케일링이 자동이기 때문에 운영 관리를 감소시킵니다.

가장 좋은 경우는, 스케일링 프로세스를 수동적으로 할 때, 예를 들어 사람이 직접 명시적으로 인스턴스를 서버 배열에 추가하고 제거하고자 할때, FaaS가 이런 것들을 잊게 해줘서 너는 행복해할 것이고, FaaS 공급 업체가 응용 프로그램을 확장 할 것이다.

FaaS가 아닌 아키텍처에서 '자동 크기 조정'을 사용하는 경우에도 여전히 설정 및 유지 관리가 필요합니다. - 이 작업은 FaaS에서 더 이상 필요하지 않습니다.

마찬가지로 모든 요청 / 이벤트가 있을 때마다 공급자가 확장을 수행하기 때문에 더 이상 메모리 부족하거나 성능에 너무 많은 부분을 처리하기 전에 처리할 수 있는 동시 요청 수에 대한 질문을 고려하지 않아도 됩니다. 또는 성능 저하가 발생하기 전에 처리 할 수있는 동시 요청 수에 대한 질문을 고려하지 않아도됩니다. 적어도 FaaS가 호스팅하는 구성 요소에는 포함되지 않습니다. 다운 스트림 데이터베이스 및 비 FaaS 구성 요소는 부하가 크게 증가 할 수 있다는 관점에서 재검토되어야합니다.

#### Reduced packaging and deployment complexity(패키징 및 배포의 복잡성 감소)

API 게이트웨이는 아직 간단하지 않지만 FaaS 기능을 패키징하고 배포하는 작업은 전체 서버를 배포하는 것과 비교하여 매우 간단합니다. 당신이하고있는 일은 코드를 컴파일하고 ziping / jar'ing 한 다음 업로드하는 것뿐입니다. puppet / chef가 없고, 시작 / 중지 셸 스크립트가 없으며 컴퓨터에 하나 또는 여러 개의 컨테이너를 배포할지 여부는 결정되지 않습니다. 시작하기 만하면 아무것도 패키징 할 필요가 없습니다. 공급 업체 콘솔에서 직접 코드를 작성할 수 있습니다 (프로덕션 코드에는 권장되지 않습니다).

이것은 설명하는 데 오랜 시간이 걸리지 않지만 일부 팀에서는 이러한 이점이 절대적으로 커질 수 있습니다. 완벽한 서버리스 솔루션을 사용하려면 시스템 관리가 필요 없습니다.

PaaS (Platform-as-a-Service) 솔루션은 배포 이점이 비슷하지만 이전에 PaaS를 FaaS와 비교했을 때 FaaS만의 확장 이점이 있습니다.

#### Time to market / experimentation

'보다 쉬운 운영 관리'는 엔지니어가 이해하는 이점이지만 비즈니스에 미치는 영향은 무엇입니까?

분명한 경우는 비용입니다. 운영 시간은 짧고 운영에 필요한 인력은 적습니다. 그러나 훨씬 더 중요한 사례는 '시장 출시'입니다. 우리 팀과 제품이 기댈 수있는 민첩한 프로세스를 중심으로 점차 증가함에 따라 우리는 끊임없이 새로운 것을 시도하고 기존 시스템을 빠르게 업데이트하려고합니다. 간단한 재배포로 안정적인 프로젝트를 신속하게 반복 할 수 있지만 새로운 아이디어 - 초기 전개 기능을 통해 적은 마찰과 최소한의 비용으로 새로운 실험을 시도 할 수 있습니다.

FaaS에 대한 새로운 아이디어 - 초기 배포 이야기는 경우에 따라, 특히 공급 업체의 생태계에서 성숙 된 정의 이벤트에 의해 트리거되는 단순한 기능에 대해 우수합니다. 예를 들어 조직에서 인프라를 통해 다양한 유형의 실시간 이벤트를 방송하기 위해 Kafka와 유사한 메시징 시스템 인 AWS Kinesis를 사용한다고 가정 해보십시오. AWS Lambda를 사용하면 단 몇 분만에 Kinesis 스트림에 대한 새로운 제작 이벤트 리스너를 개발하고 배포 할 수 있습니다. 하루에 여러 가지 실험을 시도 할 수 있습니다!

웹 기반 API의 경우 대부분의 경우 아직 동일하지는 않지만 다양한 오픈 소스 프로젝트와 소규모 구현이 앞장서고 있습니다. 나중에 더 자세히 논의하겠습니다.

### ‘Greener’ computing?(친환경 컴퓨팅)

지난 수십 년 동안 전세계 데이터 센터의 규모와 크기가 폭발적으로 증가했으며 이와 함께 많은 에너지, 서버 및 네트워크 스위치를 구축하는 데 필요한 다른 모든 물리적 자원도 함께 사용되었습니다. Apple, Google 등은 재생 가능 에너지 원 근처에서 데이터 센터 일부를 호스팅하여 해당 사이트의 화석 연료 연소 영향을 줄이는 방법에 대해 이야기합니다.

이러한 엄청난 성장의 이유 중 하나는 유휴 상태이지만 전원이 켜져있는 서버의 수입니다.

> 비즈니스 및 엔터프라이즈 데이터 센터의 일반적인 서버는 연간 최대 평균 컴퓨팅 출력의 5 ~ 15 %를 제공합니다. --포브스

이는 비효율적이며 환경에 막대한 영향을줍니다.

한편으로는 클라우드 인프라가 도움이되었을 가능성이 높습니다. 기업들은 필요한 모든 서버를 사전에 장기간 제공하지 않고 필요에 따라 더 많은 서버를 '구매할 수 있기 때문입니다. 그러나 서버를 쉽게 프로비저닝하면 많은 용량의 서버가 적절한 용량 관리없이 방치되는 경우 상황이 악화 될 수 있다고 주장 할 수 있습니다.

자체 호스팅, IaaS 또는 PaaS 인프라 솔루션 사용 여부에 관계없이 수개월 또는 수년간 계속 될 애플리케이션에 대한 용량 결정을 내리고 있습니다. 일반적으로 용량과 초과 공급을 관리하는 것에 대해서는 신중해야하며 적절하게 설명하면 비효율적입니다. Serverless 접근법을 통해 우리는 더 이상 그러한 용량 결정을 스스로하지 않습니다. - 우리는 Serverless 공급 업체가 우리의 요구에 맞는 충분한 컴퓨팅 용량을 실시간으로 제공 할 수있게했습니다. 그런 다음 공급 업체는 고객에 대해 자체적으로 용량 결정을 내릴 수 있습니다.

이러한 차이는 기존의 용량 관리 방식에 비해 환경 영향을 줄이면서 데이터 센터 전반에 걸쳐 자원을 훨씬 더 효율적으로 사용하게합니다.

## Drawbacks

소중한 독자 여러분, 무지개와 유니콘, 그리고 반짝 반짝 빛나는 모든 것들을 즐기십시오. 현실의 젖은 물고기가 얼굴 주위를 때리는 것처럼 추악 해지기 시작했기 때문입니다.

Serverless 아키텍처에 대해 좋아할만한 점이 많습니다. 많은 약속이 있다고 생각하지 않는다면 시간을 낭비하지 않아도되지만 상당한 트레이드 오프가 있습니다. 이 중 일부는 개념에 내재되어 있습니다. 진보에 의해 완전히 고쳐질 수는 없으며 항상 고려해야 할 것입니다. 다른 것들은 현재의 구현으로 내려 가고 있으며 시간이 지나면 해결 된 것을 볼 수있을 것입니다.

### Inherent Drawbacks

#### Vendor control

아웃소싱 전략을 사용하면 일부 시스템을 타사 공급 업체에 제공하는 것을 포기합니다. 이러한 제어 불능은 시스템 다운 타임, 예기치 않은 한계, 비용 변경, 기능 손실, 강제 API 업그레이드 등으로 나타날 수 있습니다. 앞서 언급 한 Charity Majors는 이 기사의 트레이드 오프 섹션에서 이 문제에 대해 자세히 설명합니다.

> [공급 업체 서비스]는 똑똑하고, 당신이 그것을 어떻게 사용할 수 있는지에 대해 강한 제약을 가할 것이기 때문에, 그들은 그들의 신뢰성 목표를 달성 할 가능성이 더 크다. 사용자가 융통성과 선택권을 가지고있을 때 그것은 혼란과 신뢰할 수없는 것을 만듭니다. 플랫폼이 당신의 행복과 수천 명의 다른 고객의 행복 사이에서 선택해야한다면, 매 시간마다 많은 것을 선택할 것입니다.  -- Charity Majors

#### Multitenancy Problems

다중 테넌트 (Multitenancy)는 여러 고객 을 위한 여러 개의 실행중인 소프트웨어 인스턴스가 동일한 시스템에서, 그리고 동일한 호스팅 애플리케이션에서 실행되는 상황을 나타냅니다. 앞서 언급한 규모의 경제를 달성하는 전략입니다. 서비스 공급 업체는 자신의 시스템을 사용하는 유일한 사람들이라는 느낌을주기 위해 애써 노력하고 있습니다. 일반적으로 훌륭한 서비스 공급 업체는 훌륭한 업무를 수행합니다. 그러나 완벽하지 않고 때로는 다중 점유 솔루션은 보안 (한 고객이 다른 고객의 데이터를 볼 수 있음), 견고성 (한 고객의 소프트웨어가 다른 고객의 소프트웨어에서 오류를 일으키는 오류) 및 성능(고 부하 고객이 다른 제품을 늦추는 원인)으로 인해 문제를 겪을 수 있습니다.

이러한 문제는 서버리스 시스템에만 국한된 것이 아니며 멀티 테넌시를 사용하는 많은 다른 서비스 제품에 존재합니다. 그러나 많은 서버리스 시스템이 새로 도입되어 이제는 이러한 시스템이 성숙 해지면 더 많은 유형의 문제가 발생할 것으로 예상됩니다.

#### Vendor lock-in

여기 Serverless 공급 업체와 관련된 세 번째 문제가 있습니다. lock-in. 벤더에서 사용하는 Serverless 기능이 다른 공급 업체에 의해 다르게 구현 될 가능성이 매우 높습니다. 운영 도구 를 업데이트해야하는 공급 업체를 전환하려면 코드를 변경해야합니다 (예 : 다른 FaaS 인터페이스를 충족해야 함). 경쟁 업체의 구현 방식과 다른 점이 있다면 디자인이나 아키텍처를 변경하십시오.

여기 Serverless 공급 업체와 관련된 세 번째 문제가 있습니다. 잠금 기능. 벤더에서 사용하는 Serverless 기능이 다른 공급 업체에 의해 다르게 구현 될 가능성이 매우 높습니다. 거의 확실하게 운영 도구(배포, 모니터링 등)를 업데이트해야하는 공급 업체를 변경하려면 코드를 변경해야 할 수 있으며(예를 들어, 상이한 FaaS 인터페이스를 만족시키기 위해), 경쟁 업체의 구현 방식과 다른 점이 있다면 디자인이나 아키텍처를 변경해야 할 수도 있습니다.

생태계의 한 부분에 대해 이 작업을 수행 할 수 있다고 하더라도 다른 아키텍처 구성 요소로 인해 잠겨있을 수 있습니다. 예를 들어, AWS Lambda를 사용하여 AWS Kinesis 메시지 버스의 이벤트에 응답한다고 가정해 보겠습니다. AWS Lambda, Google Cloud Functions 및 Microsoft Azure Functions의 차이점은 비교적 적지만 후자의 2개 공급 업체 구현을 직접 AWS Kinesis 스트림에 직접 연결할 수는 없습니다. 즉, 한 솔루션에서 다른 솔루션으로 코드를 이동하거나 이식하는 것은 인프라의 다른 부분도 이동하지 않으면 불가능합니다.

그리고 마침내 다른 공급 업체의 기능으로 시스템을 다시 구현하는 방법을 찾더라도 공급 업체가 제공하는 것에 따라 마이그레이션 프로세스를 계속 수행하게됩니다. 예를 들어 1 BaaS 데이터베이스에서 다른 BaaS 데이터베이스로 전환하는 경우 원본 및 대상 공급 업체의 내보내기 및 가져 오기 기능으로 원하는 작업을 수행 할 수 있습니까? 그리고 비록 그들이 비용과 노력의 어느 정도의 금액으로?

이 중 일부에 대한 가능한 완화책 중 하나는 다중 Serverless 공급 업체의 신흥 일반 추상화 일 수 있으며 나중에 더 자세히 논의 할 것입니다.

#### Security concerns

이는 실제로 기사 자체만으로는 충분하지만 Serverless 접근 방식을 채택하면 많은 보안 질문을 할 수 있습니다. 이들 중 두 가지는 다음과 같지만 고려해야 할 다른 것들이 많이 있습니다.

- 사용하는 각각의 서버리스 벤더만큼 생태계에 수용된 다양한 보안 구현의 수가 증가합니다. 이로 인해 악의적 인 의도와 공격의 성공 가능성이 높아집니다.
- 모바일 플랫폼에서 직접 BaaS 데이터베이스를 사용하는 경우, 전통적인 어플리케이션에서 서버 응용 프로그램이 제공하는 보호 장벽을 잃어 가고 있습니다. 이것은 거래가 아니지만 응용 프로그램을 설계하고 개발할 때 상당한주의가 필요합니다.

#### Repetition of logic across client platforms(클라이언트 플랫폼에 걸친 로직 반복)





# Origin of ‘Serverless’

The term ‘Serverless’ is confusing since with such applications there are both server hardware and server processes running somewhere, but the difference to normal approaches is that the organization building and supporting a ‘Serverless’ application is not looking after the hardware or the processes - they are outsourcing this to a vendor.

First usages of the term seem to have appeared around 2012, including this article by Ken Fromm. Badri Janakiraman says that he also heard usage of the term around this time in regard to continuous integration and source control systems being hosted as a service, rather than on a company’s own servers. However this usage was about development infrastructure rather than incorporation into products.

We start to see the term used more frequently in 2015, after AWS Lambda’s launch in 2014 and even more so after Amazon’s API Gateway launched in July 2015. Here’s an example where Ant Stanley writes about Serverless following the API Gateway announcement. In October 2015 there was a talk at Amazon’s re:Invent conference titled “The Serverless Company using AWS Lambda”, referring to PlayOn! Sports. Towards the end of 2015 the ‘Javascript Amazon Web Services (JAWS)’ open source project renamed themselves to the Serverless Framework, continuing the trend.

Fast forward to today (mid 2016) and one sees examples such as the recent Serverless Conference, plus the various Serverless vendors are embracing the term from product descriptions to job descriptions. Serverless as a term, for better or for worse, is here to stay.


## 참고

- https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4_%EC%BB%B4%ED%93%A8%ED%8C%85
- https://martinfowler.com/articles/serverless.html
