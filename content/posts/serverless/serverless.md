---
date: "2018-03-20T13:37:00+09:00"
title: "Serverless"
authors: ["1000jaeh"]
series: []
categories:
  - posts
tags:
  - serverless
  - faas
  - event-driven
  - lambda
  - reactive
cover:
  image: ""
  caption: ""
description: ""
draft: true
---
## 서버리스 컴퓨팅이란

서버리스 컴퓨팅(serverless computing)은 클라우드 컴퓨팅 실행 모델의 하나로, 클라우드 제공자는 동적으로 머신 자원의 할당을 관리한다. 가격은 미리 구매한 용적 단위가 아닌 애플리케이션이 소비한 자원의 실제 양에 기반을 둔다.[1] 유틸리티 컴퓨팅의 일종이다.

서버리스 컴퓨팅은 여전히 서버가 필요하므로 부적절한 명칭이다.[1] "서버리스 컴퓨팅"이라는 이름이 사용된 이유는 서버 관리 및 용적 계획 결정이 완전히 개발자나 운영자로부터 숨겨져 있기 때문이다. 서버리스 코드는 마이크로서비스처럼 전통적인 스타일로 배치(deploy)된 코드와 결합하여 사용할 수 있다. 대안으로, 애플리케이션들은 순수 서버리스 형태로 작성할 수 있으며 프로비전된 서버를 아예 사용하지 않는다.[2]

## 서버리스 프레임워크

서버리스 프레임워크들은 서버리스 애플리케이션을 더 쉽게 빌드, 테스트, 디플로이할 수 있도록 설계된다. 일부 저명한 것들은 다음과 같다:

서버리스 프레임워크
Kubeless
Fission
Funktion
Nuclio
OpenFaas
Oracle Fn

## 개요

서버리스 아키텍처는 써드 파티 서비스 (Backend as a service 또는 "BaaS"로 인식 함) 또는 일시적인 컨테이너 (function as a service 또는 "FaaS")에서 실행되는 사용자 정의된 코드에 크게 의존하는 응용프로그램을 가리키며, 가장 잘 알려진 벤더 호스트는 현재 AWS Lambda입니다. 이러한 아이디어를 사용하고, 많은 행동들이 프런트 엔드로 옮김으로써, 이러한 아키텍처는 응용 프로그램 뒤에 앉아있는 '항상 켜져있는'서버 시스템에 대한 필요성을 없애줍니다. 상황에 따라, 이러한 시스템은 공급 업체에 대한 종속성 및 지원 서비스에 대한 미성숙에 대한 운영 비용과 복잡성을 크게 줄일 수 있습니다.

Serverless는 소프트웨어 아키텍처 세계에서 가장 뜨거운 주제입니다. 우리는 이미 책, 오픈 소스 프레임 워크, 많은 공급 업체 제품, 심지어 주제로 개최되는 컨퍼런스까지보고 있습니다. 하지만 Serverless는 무엇이며 왜 고려 가치가 있습니까? 이 진화하는 출판물을 통해 나는이 질문들에 대해 당신에게 약간의 계몽을하기를 희망합니다.

우선 우리는 접근 방식의 장점과 단점에 대해 중립성을 유지하려고 노력하는 Serverless의 '무엇'을 살펴볼 것입니다. 나중에이 주제들을 살펴 보겠습니다.

## What is Serverless?

소프트웨어의 많은 트렌드와 마찬가지로 '서버리스'가 무엇인지에 대한 명확한 관점은 없으며, 실제로 도움이 되지 않는 2가지 의미가 다가오지만, 중복되는 영역이 있습니다.:

1. Serverless는 처음에는 서버 측의 로직 및 상태를 관리하기 위해 3rd 파티 응용프로그램/서비스(클라우드에 있는..)에 상당히 또는 완전히 의존하는 응용 프로그램을 설명하는 데 사용되었습니다. 이들은 일반적으로 Parse, Firebase와 같은 클라우드 액세스 가능한 데이터베이스의 광대 한생태계, 인증 서비스 (Auth0, AWS Cognito) 등을 사용하는 '리치 클라이언트'응용 프로그램 (단일 페이지 웹 응용 프로그램 또는 모바일 응용 프로그램)입니다. 이러한 유형의 서비스 이전에 '(모바일) Backend as a Service'로 설명했으며, 이 기사의 나머지 부분에서 'BaaS'를 약식으로 사용하게 될 것입니다.

2. Serverless는 응용 프로그램 개발자가 일부 서버 측 로직을 여전히 작성한 응용 프로그램을 의미 할 수도 있지만, 기존 전통적인 아키텍처와 달리 이벤트가 트리거되고, 일시적이며(한 번의 호출에 대해서만 지속될 수 있음), 3rd 파티에서 완전히 관리되는 무상태 저장 컴퓨팅 컨테이너에서 실행됩니다. 이것을 생각하는 한 가지 방법은 'Functions as a Service / FaaS'입니다. AWS Lambda는 현재 FaaS에서 가장 널리 사용되는 구현 중 하나이지만 다른 것들도 있습니다. 나는 이 기사의 나머지 부분에서 Serverless의 의미에 대한 약식으로 'FaaS'를 사용할 것이다. 

대부분이 두 번째 영역에 대해 이야기 할 것입니다. 왜냐하면 이 영역은 최신 기술이며 일반적으로 기술 아키텍처에 대해 생각하는 방식과 큰 차이가 있으며, Serverless를 중심으로 많은 선전을 이끌었습니다. 그러나 이러한 개념은 실제로 관련되어 있으며 사실 수렴하고 있습니다. 좋은 예가 Auth0입니다. 처음에는 BaaS 'Authentication as a Service'으로 시작했지만, Auth0 웹태스크는 FaaS 공간으로 들어간 것입니다.

또한 'BaaS 모양의'애플리케이션을 개발할 때, 특히 모바일 앱과 달리 'rich'웹 기반 앱을 개발할 때, 많은 경우 맞춤 서버 측 functionality가 어느 정도 필요합니다. FaaS function들은 특히 BaaS 서비스와 어느 정도 통합되어 있다면 좋은 해결책이 될 수 있습니다.  이러한 기능의 예로는 데이터 유효성 검사 (임포스터 클라이언트로부터 보호) 및 연산 집약적 처리 (예 : 이미지 또는 비디오 조작)가 있습니다.

## A couple of examples

### UI-driven applications

서버 측 로직을 사용하는 전통적인 3 계층 클라이언트 지향 시스템에 대해 생각해 봅시다. 좋은 예가 전형적인 전자 상거래 앱입니다 (감히 내가 온라인 애완 동물 상점이라고 말합니까?)

전통적으로 아키텍처는 다음과 같이 보일 것이고, 클라이언트 측 HTML / Javascript 구성 요소를 사용하여 서버 측 Java에서 구현되었다고 가정해 봅니다.

![traditional](https://martinfowler.com/articles/serverless/ps.svg)

이 아키텍처를 사용하면 클라이언트는 서버 애플리케이션이 구현하는 인증, 페이지 탐색, 검색, 트랜잭션과 같은 시스템의 많은 로직을 사용하여 비교적 지능적이지 못합니다.

Serverless 아키텍처를 사용하면 이렇게 될 수 있습니다.

![serverless](https://martinfowler.com/articles/serverless/sps.svg)

이것은 대단히 단순화 된 견해이지만, 여기에서도 많은 변화가 있었습니다. 이는 아키텍처 마이그레이션의 권장 사항이 아니므로 일부 서버리스 개념을 폭넓게 드러내는 도구로 사용하고 있습니다.

1. 원래 응용 프로그램의 인증 로직을 삭제하고 3rd파티 BaaS 서비스로 대체했습니다.
2. BaaS의 또 다른 예를 사용하면, 클라이언트가 데이터베이스의 하위 집합(상품목록용)에 직접 액세스 할 수 있게 되었습니다. 해당 데이터베이스 자체는 3rd파티 호스트됩니다(예를들어, AWS Dynamo). 이러한 방식으로 데이터베이스에 액세스 할 수있는 서버 리소스에서 데이터베이스에 액세스하는 클라이언트의 보안 프로필이 다를 수 있습니다.
3. 앞의 두 가지 사항은 매우 중요한 세 번째를 의미합니다. - Pet Store 서버에 있던 일부 로직이 이제 클라이언트 내에 있습니다. 사용자 세션 추적, 응용 프로그램의 UX 구조 이해(예를들어, page navigation), 데이터베이스 읽기 및 유용한 뷰로 변환 등이 포함됩니다. 클라이언트는 실제로 단일 페이지 응용 프로그램이 되는 과정에 있습니다.
4. 일부 UX 관련 기능 예를들어, 집중적 인 계산이거나 상당한 양의 데이터에 대한 액세스가 필요한 경우를 서버에 유지하려고 할 수 있습니다. 예를 들면 '검색'입니다. 항상 실행 중인 서버가 아닌 검색 기능을 위해 우리는 API 게이트웨이를 통해 HTTP 요청에 응답하는 FaaS 기능을 구현할 수 있습니다. 우리는 클라이언트와 서버 기능 모두, 제품 데이터를 위한 동일한 데이터베이스에서 읽을 수 있습니다. 원래 서버는 Java로 구현되었으며, AWS Lambda(이 경우 선택 가능한 FaaS 공급 업체)는 Java로 구현된 기능을 지원하므로, 완전히 다시 쓰지 않아도 Pet Store 서버에서 Pet Store Search 기능으로 검색 코드를 이식 할 수 있습니다.
5. 마지막으로 우리는 '구매'기능을 클라이언트에서 다시 구현하지 않고 보안상의 이유로 서버 측에 유지하면서 다른 FaaS 기능으로 대체 할 수 있습니다. 또한 API 게이트웨이가 앞장서고 있습니다.

### Message-driven applications

다른 예로 백엔드 데이터 처리 서비스가 있습니다. UI 요청에 신속하게 응답해야하는 사용자 중심의 응용 프로그램을 작성중이지만, 2차적으로 발생하는 모든 유형의 활동을 모두 캡처하려고 한다고 가정 해보십시오. 온라인 광고 시스템에 대해 생각해 봅시다. - 사용자가 광고를 클릭하면 광고 대상으로 신속하게 리디렉션 할 수 있지만, 동시에 클릭이 발생했으므로 광고주에 청구할 수 있도록 fact를 수집해야 합니다. (이 예는 가설이 아닙니다. Intent Media의 전직 팀이 최근이 정확하게 재설계를 진행했습니다.)

전통적으로, 아키텍처는 이와 같이 보일 수 있습니다. '광고 서버'는 사용자에게 동기식으로 응답하지만, - 우리는이 예를 위해서 그 상호 작용에 관심이 없다.- 데이터베이스에 업데이트하는 '클릭 프로세서'응용 프로그램에서 비동기식으로 처리 할 수있는 메시지를 채널에 게시합니다. 예를 들어, 광고주의 예산을 줄이려면....

![message-driven-1](https://martinfowler.com/articles/serverless/cp.svg)

Serverless 세계에서 이것은 다음과 같습니다:

![message-driven-2](https://martinfowler.com/articles/serverless/scp.svg)

첫 번째 예제와 비교할 때 아키텍처에 대한 차이점은 훨씬 적습니다. 우리는 수명이 긴 소비자 애플리케이션을 공급 업체가 제공하는 이벤트 중심 컨텍스트 내에서 실행되는 FaaS 기능으로 대체했습니다. 공급 업체는 Message Broker와 FaaS 환경을 모두 제공합니다. 두 시스템은 서로 밀접하게 연결되어 있습니다.

FaaS 환경은 기능 코드의 여러 복사본을 인스턴스화하여 여러 번의 클릭을 동시에 처리 할 수 ​​있습니다. - 원래 프로세스를 작성한 방법에 따라 고려해야 할 새로운 개념일 수 있습니다.

### Unpacking 'Function as a Service'

우리는 이미 FaaS 아이디어를 많이 언급했지만, 실제로 그것이 의미하는 바를 파헤 칠 때가되었습니다. 이를 위해 Amazon의 Lambda 제품에 대한 개시 설명을 살펴 보겠습니다. 몇 가지 토큰을 추가했습니다.

> AWS Lambda를 사용하면 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있습니다. (1) ... Lambda를 사용하면, 사실상 모든 유형의 응용 프로그램 또는 백엔드 서비스 (2)에 대한 코드를 실행할 수 있습니다. 코드를 업로드하기 만하면 Lambda가 고 가용성으로 코드를 실행 (3)하고 확장 (4)하는 데 필요한 모든 작업을 처리합니다. 다른 AWS 서비스 (5)에서 자동으로 트리거하거나 웹 또는 모바일 앱 (6)에서 직접 호출하도록 코드를 설정할 수 있습니다.

AWS Lambda를 사용하면 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있습니다. (1) ... Lambda를 사용하면, 사실상 모든 유형의 응용 프로그램 또는 백엔드 서비스에 대한 코드를 실행할 수 있습니다. (2) 코드를 업로드하면 Lambda가 고 가용성으로 코드를 실행하고(3)  확장하는데 (4) 필요한 모든 것을 처리합니다. 다른 AWS 서비스에서 자동으로 트리거하거나 (5) 웹 또는 모바일 앱에서 직접 호출하도록 코드를 설정할 수 있습니다 (6).

1. 근본적으로 FaaS는 자체 서버 시스템 또는 자체 서버 응용 프로그램을 관리하지 않고 백엔드 코드를 실행하는 것입니다. 두 번째 조항은 - 서버 응용 프로그램 - 컨테이너 및 PaaS (Platform as a Service)와 같은 다른 현대 구조적인 트렌드와 비교할 때 중요한 차이점입니다. FaaS가 수행하는 이전의 클릭 처리 예제로 돌아 가면 클릭 처리 서버(실제 시스템이지만 확실히 특정 애플리케이션)를 프로비저닝 된 서버나 항상 실행중인 응용 프로그램이 필요없는 것으로 대체합니다.

2. FaaS 오퍼링은 특정 프레임 워크 또는 라이브러리에 코딩 할 필요가 없습니다. FaaS 기능은 언어 및 환경과 관련하여 일반적인 응용 프로그램입니다. 예를 들어 AWS Lambda 함수는 Javascript, Python 및 JVM 언어(Java, Clojure, Scala, etc.)에서 'first class'로 구현 될 수 있습니다. 그러나 람다 함수는 배포 아티팩트에 번들 된 다른 프로세스를 실행할 수 있으므로, 실제로 유닉스 프로세스로 컴파일 할 수 있는 언어를 사용할 수 있습니다(나중에 Apex를 참조하십시오). FaaS 함수는 특히 상태 및 실행시간과 관련하여 중요한 아키텍처 제한이 있으며 곧 이에 관해서 설명 할 것입니다. 클릭 처리의 예를 다시 생각해 봅시다. - FaaS로 이동할 때 변경해야하는 유일한 코드는 '기본 메소드 / 시작'코드입니다. 이 코드는 삭제되고 최상위 메시지 핸들러 인 특정 코드(예 : 'message listener interface'구현)일 가능성이 있지만, 이것은 메소드 시그니처의 변경 일 수 있습니다. 나머지 코드 (예 : 데이터베이스에 쓰는 코드)는 모두 FaaS 세계에서 다를 수 있습니다.

3. 배포를 실행할 서버 응용 프로그램이 없으므로 기존 시스템과 매우 다릅니다. - 우리는 FaaS 제공자에게 코드를 업로드하면 그게 다 입니다. 지금은 일반적으로 코드 정의 (예 : zip 또는 JAR 파일)를 업로드 한 다음, 독점 API를 호출하여 업데이트를 시작하는 것을 의미합니다.

4. 수평적 확장은 완전히 자동이고 탄력적이며 공급자가 관리합니다. 만약 시스템에서 100 개의 요청을 병렬로 처리해야하는 경우, 공급자는 사용자가 추가 구성을하지 않아도이를 처리합니다. 함수를 실행하는 '계산 컨테이너'는 FaaS 제공자가 순전히 런타임 필요에 의해 유도 된 프로비저닝 및 파기와 함께 일시적입니다. 클릭 프로세서로 돌아 갑시다. 우리가 좋은 하루 보내고 고객이 평소보다 10 배 많은 광고를 클릭하고 있다고 가정 해보십시오. 클릭 처리 애플리케이션에서 이 문제를 처리 할 수 ​​있습니까? 예를 들어 한 번에 여러 메시지를 처리 ​​할 수 ​​있도록 코딩 했습니까? 우리가 경우라도 응용 프로그램의 인스턴스를 하나만 구동해도 로드를 처리하기에 충분합니까? 여러 프로세스를 실행할 수있는 경우 자동으로 자동 크기 조정이 수행됩니까? 아니면 수동으로 재구성해야합니까? FaaS를 사용하면 병렬 처리를 가정하여 미리 함수를 작성해야하지만, FaaS 제공자의 해당 시점부터 자동으로 모든 확장 요구를 처리합니다.

5. FaaS의 함수는 공급자가 정의한 이벤트 유형에 의해 트리거됩니다. Amazon AWS와 같은 이러한 자극에는 S3 (파일) 업데이트, 시간 (scheduled tasks) 및 메시지가 메시지 버스에 추가됩니다(예. Kinesis). 함수는 일반적으로 연결된 이벤트 소스와 관련된 매개 변수를 제공해야합니다. 클릭 프로세서를 통해 우리는 이미 FaaS - 메시지브로커를 지원하는 - 를 사용하고 있다는 가정을했습니다. 그렇지 않으면 우리는 메시지 프로듀서로 변경해야 할 필요가 있었습니다.

6. 또한 대부분의 공급자는 일반적으로 일종의 API 게이트웨이에서 인바운드 HTTP 요청에 대한 응답으로 함수를 트리거 할 수 있습니다. (예 : AWS API 게이트웨이, 웹 태스크). 우리는 Pet Store 예제에서 '검색'및 '구매'기능을 사용했습니다.

### State

FaaS 함수는 로컬 (기계 / 인스턴스 바운드) 상태 일 때 상당한 제한이 있습니다. 즉, 주어진 함수 호출에 대해 작성한 프로세스 또는 호스트 상태가 후속 호출에 사용 가능하지 않다고 가정해야 합니다. (In short you should assume that for any given invocation of a function none of the in-process or host state that you create will be available to any subsequent invocation. ) 여기에는 RAM의 상태와 로컬 디스크에 기록 할 수있는 상태가 포함됩니다. 즉, 배포 단위 관점에서 FaaS 함수는 stateless입니다.

이는 독특한 아키텍처는 아니지만 애플리케이션 아키텍처에 엄청난 영향을 미칩니다. '12 요소 애플리케이션'개념에는 똑같은 제한이 있습니다.

이 제한을 감안할 때 대안은 무엇입니까? 일반적으로 FaaS 함수는 자연스럽게 상태를 갖지 않거나 - 즉 입력값에 대한 순수한 함수 변환을 제공 -, 요청을 가로 지르는 상태를 저장하거나 요청을 처리하기 위한 추가 입력을 위해 데이터베이스, 교차 애플리케이션 캐시 (예 : Redis) 또는 네트워크 파일 저장소 (예 : S3)를 사용합니다. .

### Excution Duration

FaaS 함수는 일반적으로 각 호출을 실행할 수있는 시간이 제한되어 있습니다. 현재 AWS 람다 함수는 5 분 이상 실행될 수 없으며 종료되면 종료됩니다.

이것은 오래 살아있는 태스크의 특정 클래스가 리아키텍쳐 없이는 FaaS 기능에 적합하지 않다는 것을 의미합니다. 예를들어, 전통적인 환경에서 조정과 실행을 모두 수행하는 하나의 장기간 task를 몇 가지 서로 다른 조정 된 FaaS 기능으로 쪼개서 만들어야 할 수도 있습니다.

### Startup Latency

현재 FaaS 기능이 요청에 응답하는 데 걸리는 시간은 많은 요인에 따라 달라지며 10ms에서 2 분 정도 소요될 수 있습니다. 

AWS Lambda를 예로 들어 좀 더 구체적으로 살펴 보도록하겠습니다. 함수가 Javascript 또는 Python으로 구현되고, 크지 않은(즉, 1000 줄 미만의 코드) 경우에는 실행하는 데 오버 헤드가 10-100 ms를 초과해서는 안됩니다. 더 큰 함수는 때때로 더 긴 시간을 볼 수 있습니다.

람다 함수가 JVM에 구현 된 경우 JVM이 회전되는 동안 가끔 응답 시간이 길어질 수 있습니다 (예 : 10 초 초과). 그러나 이는 다음 시나리오 중 하나에서만 발생합니다.

- 함수는 호출 간 간격이 10 분을 초과하지 않도록 이벤트를 자주 처리하지 않습니다.
- 트래픽이 급격히 증가합니다. 예를 들어 일반적으로 초당 10 개의 요청을 처리하지만 10 초 이내에 초당 최대 100 개의 요청을 처리합니다.

이 중 전자는 특정 상황에서 5 분마다 기능을 핑핑 (pinging)하는 추악한 해킹으로 피할 수 있습니다.

이러한 문제가 우려됩니까? 응용 프로그램의 스타일과 트래픽 모양에 따라 다릅니다. 저의 전 팀은 자바로 구현 된 비동기식 메시지 처리 람다 (Lambda) 애플리케이션을 가지고 있습니다. 이 애플리케이션은 하루에 수억 개의 메시지를 처리하며, 시작시의 대기 시간에는 관심이 없습니다. 저 지연 응용 프로그램을 작성하는 경우, 구현시 사용하는 언어와 상관없이 현재 FaaS 시스템을 사용하고 싶지 않을 것입니다.

앱에 이와 같은 문제가 발생할 수도 있다고 생각하든 그렇지 않든간에 프로덕션과 같은 로드로 테스트하여 어떤 성능을 확인해야합니다. 유스 케이스가 작동하지 않는 경우 FaaS 벤더가 개발하는 주요 영역이기 때문에 몇 달 이내에 다시 시도 할 수 있습니다.

### API Gateway

![apigateway](https://martinfowler.com/articles/serverless/ag.svg)

이전에 닦았 던 FaaS의 한 측면은 'API 게이트웨이'입니다. API 게이트웨이는 라우트 / 엔드 포인트가 구성에서 정의되고 각 라우트가 FaaS 기능과 연관되는 HTTP 서버입니다. API 게이트웨이는 요청을 받으면 요청과 일치하는 라우팅 구성을 찾은 다음 관련 FaaS 기능을 호출합니다. 일반적으로 API 게이트웨이는 http 요청 매개 변수에서 FaaS 기능에 대한 인수를 입력하도록 허용합니다. API 게이트웨이는 FaaS 함수 호출의 결과를 http 응답으로 변환하고 이를 원래 호출자에게 리턴합니다.

Amazon Web Services에는 자체 API 게이트웨이가 있으며 다른 공급 업체에서도 유사한 기능을 제공합니다.

순전히 라우팅 요청을 넘어 API 게이트웨이는 인증, 입력 유효성 검사, 응답 코드 매핑 등을 수행 할 수도 있습니다. 당신의 Spidey-sense는 실제로 이것이 좋은 아이디어인지 아닌지에 대해 윙윙 거리고 있습니다. - 우리는 나중에 이것을 더 고려할 것입니다.

API Gateway + FaaS의 한 가지 사용 사례는 FaaS 기능에서 비롯된 모든 확장, 관리 및 기타 이점을 사용하여 서버가없는 방식으로 http 기반 마이크로 서비스를 만드는 것입니다.

현재 API 게이트웨이를위한 툴링은 미숙하고 API 게이트웨이가있는 어플리케이션을 정의하는 것이 가능하지만 그것은 미미한 정도입니다.(At present tooling for API gateways is achingly immature and so while defining applications with API gateways is possible it’s most definitely not for the faint-hearted)

### Tooling

실제로 적용하기에 미성숙한 API 게이트웨이 툴링에 관한 위의 코멘트는, 전체적으로, Serverless FaaS에 일반적으로 적용됩니다. 그러나 예외가 있습니다. - 한 가지 예가 Auth0 Webtask이며, 이는 툴링에서 Developer UX에 우선 순위를 둡니다. Tomasz Janczuk은 최근 Serverless Conference에서 이것을 잘 보여주었습니다.

디버깅 및 모니터링은 일반적으로 Serverless 애플리케이션에서 까다로울 수 있습니다.이 기사의 후속 기사에서 더 자세히 살펴 보겠습니다.

### Open Source

Serverless FaaS 애플리케이션의 주요 이점 중 하나는 투명한 프로덕션 런타임 프로비저닝이며, 오픈 소스는 현재 Docker 및 컨테이너로 불리는 세상과 관련이 없습니다. 앞으로는 온 프레미스 (on premise) 또는 개발자 워크 스테이션에서 실행될 인기있는 FaaS / API 게이트웨이 플랫폼 구현을 보게 될 것입니다. IBM의 OpenWhisk는 이러한 구현의 예이며 이 구현 또는 대안 구현이 채택 여부를 결정하는 것이 흥미로울 것입니다.

런타임 구현과는 별도로 이미 정의, 배포 및 런타임 지원을 지원하는 오픈 소스 도구 및 프레임 워크가 있습니다. 예를 들어 Serverless Framework는 AWS가 제공하는 첫 번째 원칙을 사용하는 것보다 API Gateway + Lambda를 사용하는 것이 훨씬 쉽습니다. Javascript는 무겁지만 JS API 게이트웨이 애플리케이션을 작성하는 경우 꼭 한 번 볼만한 가치가 있습니다.

또 다른 예는 'AWS Lambda 기능을 손쉽게 구축, 배포 및 관리하는 프로젝트'인 Apex입니다. Apex에서 특히 흥미로운 점 중 하나는 Amazon에서 직접 지원하는 언어 이외의 언어로 람다 함수를 개발할 수 있다는 것입니다. 예를 들어, Go.

## What isn't Serverless?

지금까지이 기사에서 '서버리스'는 '백엔드 서비스'와 '서비스 기능'이라는 두 가지 아이디어의 결합을 의미한다고 정의했습니다. 나는 또한 이들 중 두 번째 기능을 파헤 쳤다.

우리가 장점과 단점 중 가장 중요한 부분을 살펴보기 전에 정의에 대해 더 많은 것을 알기를 원하거나 Serverless가 정의하지 않은 것을 정의하고 싶습니다. 나는 몇몇 사람들 (최근에 나를 포함해서)이 이런 것들에 대해 혼란스러워하며 명확성을 위해 토론 할 가치가 있다고 생각한다.

### Comparison with PaaS

Serverless FaaS 기능이 12-Factor 애플리케이션과 매우 유사하다는 점을 감안할 때 사실 Heroku와 같은 'PaaS (Platform as a Service)'의 또 다른 형태입니까? 간단한 대답은 Adrian Cockcroft를 참조하십시오.

> adrian cockcroft
> @adrianco
> If your PaaS can efficiently start instances in 20ms that run for half a second, then call it serverless.
> 만약 PaaS가 30초에 구동되는 인스턴스를 20ms 안에 효과적으로 기동한다면, 서버리스라 부를 수 있다.

즉, 대부분의 PaaS 응용 프로그램은 모든 요청에 ​​대해 전체 응용 프로그램을 위아래로 가져 오는 방향으로 조정되지 않지만 FaaS 플랫폼은 정확히 이 기능을 수행합니다.

좋아요. 그렇지만 12- 팩터 앱 개발자가 되어도 코드 작성 방법에는 차이가 없습니다. 사실이지만 앱 운영 방식에는 큰 차이가 있습니다. 우리는 모두 개발팀에 익숙한 엔지니어이므로 개발과 관련하여 최대한 많은 작업을 생각하고 있습니다. 그렇죠?

FaaS와 PaaS의 주요 운영상의 차이점은 규모 조정입니다. 대부분의 PaaS에서는 예를 들어, 헤로쿠와 함께 얼마나 많은 Dynos가 기동되길 원합니까와 같은 규모에 대해 생각할 필요가 있습니다. 
FaaS 응용 프로그램을 사용하면 이것이 완전히 투명합니다. PaaS 응용 프로그램을 자동 확장하도록 설정해도 개별 요청 수준으로는 수행하지 않으므로(매우 구체적인 트래픽 프로필이없는 한
), FaaS 응용 프로그램은 비용면에서 훨씬 효율적입니다.

이러한 이점이 주어진다면, 왜 PaaS를 사용하겠는가? 몇몇 이유가 있겠지만, API 게이트웨이의 성숙도와 툴링이 가장 큰 이유일 것이다. 또한 PaaS에 구현 된 12 요소 애플리케이션은 최적화를 위해 인앱 읽기 전용 캐시를 사용할 수 있지만, 이는 FaaS 기능을 위한 옵션이 아닙니다.

### Comparison with containers

Serverless FaaS의 이유 중 하나는 운영 체제 수준에서 계산 프로세스를 관리하지 않아도된다는 것입니다. Heroku와 같은 Platform-as-a-Service는 또 다른 하나이며, PaaS가 Serverless FaaS와 다른 점은 위에 설명했습니다. 프로세스의 또 다른 대중적인 추상화는 Docker가 그러한 기술의 가장 보편적 인 예가되는 컨테이너입니다. 또한 OS 레벨 배포에서 개별 응용 프로그램을 추상화하는 Mesos 및 Kubernetes와 같은 컨테이너 호스팅 시스템의 인기가 증가하고 있습니다. 또한 Amazon ECS 및 Google Container Engine과 같은 클라우드 호스팅 컨테이너 플랫폼은 Serverless FaaS와 마찬가지로 자체 서버 시스템을 전혀 관리하지 않아도됩니다. 따라서 컨테이너 주위에 모든 momentum이 주어지면 Serverless FaaS를 고려해 볼 가치가 있습니까?

기본적으로 PaaS에 대한 논쟁은 여전히 ​​컨테이너를 가지고 있습니다. Serverless FaaS 스케일링은 자동으로 관리되고 투명하며 세분화됩니다. 컨테이너 플랫폼은 아직 그러한 솔루션을 제공하지 않습니다.

게다가 저는 지난 몇 년 동안 엄청난 인기를 보았을 때 컨테이너 기술이 아직 성숙하지 않았다고 주장 할 것입니다. Serverless FaaS가 성숙했다는 것을 말하는 것이 아니라, 당신이 원하는 rough edges를 선택하는 것이 여전히 그 순서입니다.(but picking which rough edges you’d like is still the order of the day).

그러나 나는 이 두 주장이 시간이 지남에 따라 얇아지기 시작할 수도 있음을 인정할 것이다. 컨테이너 플랫폼의 관리 기능이 없는 자동 스케일링은 아직 Serverless FaaS 수준이 아니지만 Kubernetes의 Horizontal Pod Autoscaling과 같은 영역을 고려해야합니다. 이러한 기능에 대해 도입된 매우 똑똑한 트래픽 패턴 분석은, 물론 부하 관련 통계를 더 많이 상상할 수 있습니다. 또한 Kubernetes의 급속한 진화는 너무 오래 전에 멋지고 간단하고 안정적인 플랫폼을 제공 할 수 있습니다.

Serverless FaaS와 호스팅 된 컨테이너 사이의 관리 및 확장의 차이가 좁아지면 단지, 이들 사이의 선택이 응용 프로그램의 스타일 및 유형으로 내려갈 수 있습니다. 예를 들어, 응용 프로그램 구성 요소 당 이벤트 유형이 거의없는 이벤트 중심 스타일에 대해 FaaS가 더 나은 선택으로 간주 될 수 있으며, 많은 진입 점이있는 동기 요청 구동 구성 요소의 경우 컨테이너가 더 나은 선택으로 간주 될 수 있습니다. 저는 5년 내에 많은 응용 프로그램과 팀이 아키텍처 접근 방식을 모두 사용할 것으로 기대하며, 그러한 사용 패턴이 나타나는 것이 매력적이게 될 것입니다.

### NoOps

Serverless는 'No Ops'를 의미하지 않습니다. 서버리스 토끼 구멍에서 얼마나 멀리 떨어져 있는지에 따라 '내부 Sys Admin 없음'을 의미 할 수도 있습니다. 여기서 고려해야 할 중요한 두 가지 사항이 있습니다(It might mean ‘No internal Sys Admin’ depending on how far down the serverless rabbit hole you go).

첫째, 'Ops'는 서버 관리 이상의 의미입니다. 또한 적어도 모니터링, 배포, 보안, 네트워킹을 의미하며 때로는 일정량의 프로덕션 디버깅 및 시스템 확장을 의미합니다. 이러한 문제는 모두 Serverless 앱에서 여전히 존재하며 문제를 해결하기위한 전략이 필요합니다. Ops는 서버가없는 세상에서 어떤면에서는 더 힘든 부분이 많습니다.

두 번째로 Sys Admin도 여전히 존재합니다. - Serverless로 아웃소싱하는 것뿐입니다. 이것이 반드시 나쁜 것은 아닙니다. - 우리는 많은 것을 아웃소싱합니다. 하지만 정확히 무엇을하려하는지에 따라 좋은 것이든 나쁜 것이든 간에 어떤 점에서는 추상화가 누출 될 수 있으며 인간의 시스템 관리자가 어딘가에서 애플리케이션을 지원하는지 알아야합니다.

Charity Majors는 최근의 Serverless Conference에서 이 주제에 대해 훌륭한 강의를했으며, 온라인에서 사용 가능 해지면 체크 아웃하는 것이 좋습니다. 그 때까지 [여기](https://charity.wtf/2016/05/31/wtf-is-operations-serverless/)링크와 [여기](https://charity.wtf/2016/05/31/operational-best-practices-serverless/)에서 그녀의 글을 읽을 수 있습니다.

### Stored Procedures as a Service

> Camille Fournier
> @skamille
> I wonder if serverless services will become a thing like stored procedures, a good idea that quickly turns into massive technical debt
> serverless 서비스가 스토어드 프로 시저와 같은 것이 될지 궁금합니다. 훌륭한 아이디어는 빠르게 대량의 기술적 부채로 변합니다.

내가 본 또 다른 테마는 Serverless FaaS가 'Stored Procedures as a Service'라는 것입니다. 필자는 FaaS 함수의 많은 예제 (이 기사에서 사용한 일부 포함)는 데이터베이스에 대한 액세스를 감싸는 작은 코드 조각이라는 사실에서 비롯된 것이라고 생각한다. 그것이 우리가 FaaS를 사용할 수있는 전부라면 그 이름이 유용 할 것이지만 실제로는 FaaS의 능력의 일부분이기 때문에 FaaS에 대한 그런 생각은 잘못된 제약이라는 것입니다.

FaaS가 언급 된 트윗에서 Camille이 언급 한 기술 부채 문제를 포함하여 저장 프로 시저와 동일한 문제가 있는지 여부를 고려해 볼 가치가 있다고합니다. FaaS의 컨텍스트에서 검토 할 가치가있는 저장된 procs를 사용하고 적용 여부를 확인하는 많은 교훈이 있습니다. 이들 중 일부는 저장 프로 시저입니다.

1. 종종 공급 업체별 언어 또는 적어도 공급 업체별 프레임 워크 / 언어 확장 기능이 필요합니다.
2. 데이터베이스 컨텍스트에서 실행해야 하므로 테스트하기가 어렵습니다.
3. 버전 제어 / 처리에 까다로운 first class 애플리케이션으로 취급됩니다.

이것들 모두가 저장된 procs의 모든 구현에 적용되는 것은 아니지만, 분명히 내가 겪어 본 문제점들이다. FaaS에 적용 할 수 있는지 알아 보겠습니다.

(1)은 지금까지 보아 왔던 FaaS 구현에 대한 관심사가 아니므로 지금 바로 목록에서 제거 할 수 있습니다.

(2)에서는 'just code' 단위 테스트를 다루는 것이 다른 코드처럼 쉽습니다. 통합 테스트는 다른 (그리고 합법적인) 질문이지만 나중에 논의 할 것입니다.

(3)에서는 FaaS 함수가 '단순한 코드'이므로 버전 제어가 정상입니다. 그러나 응용 프로그램 패키징과 관련하여 아직 성숙한 패턴이 없습니다. 앞서 언급 한 Serverless 프레임 워크는 자체 양식을 제공하며, AWS는 2016 년 5 월 Serverless 컨퍼런스에서 패키징을위한 무언가 ('Flourish') 작업을하고 있다고 발표했지만 현재로서는 또 다른 정당한 관심사입니다.

## Benefits

지금까지 저는 대부분 Serverless 아키텍처가 의미하는 바를 정의하고 설명하는 데 주로 집중하려고했습니다. 이제는 응용 프로그램을 설계하고 배포하는 것과 같은 몇 가지 이점과 단점에 대해 논의 할 것입니다.

이 기술 중 일부는 매우 새롭다는 사실을 바로 알아 두는 것이 중요합니다. AWS Lambda - 선도적인 FaaS 구현 - 는 글을 작성하는 시점에서 만들어진지 2 년이 안됬습니다. 우리가 느끼는 이점의 일부는 다른 2 년 후에 되돌아 볼 때 과대 광고로 끝날 수 있습니다. 반면에 단점 중 일부는 해결 될 것입니다.

이것은 검증되지 않은 개념이기 때문에 큰 고려 사항없이 Serverless를 사용하기로 결정하지 않아야합니다. 이 장단점 목록이 당신이 그러한 선택에 도움이되기를 바랍니다.

우리는 무지개와 유니콘의 땅에서 시작하여 Serverless의 이점을 살펴볼 것입니다.

### Reduced operational cost

Serverless는 가장 단순한 아웃소싱 솔루션입니다. 그것은 당신이 스스로 관리 할 수도있는 서버, 데이터베이스 그리고 애플리케이션 로직을 관리하기 위해 누군가에게 돈을 지불하는 것을 허용합니다. 다른 많은 사람들도 사용할 수있는 정의 된 서비스를 사용하고 있으므로 규모의 경제 효과를 볼 수 있습니다. 하나의 공급 업체가 수천 개의 매우 유사한 데이터베이스를 실행하기 때문에 관리되는 데이터베이스의 비용을 덜 지불하게됩니다.

비용 절감은 인프라 비용과 사람 (운영 / 개발) 비용이라는 두 가지 측면의 총합으로 나타납니다. 비용 증가의 일부는 다른 사용자와 인프라 (하드웨어, 네트워킹)를 공유함으로써 만 얻을 수 있지만, 아웃소싱 된 서버가없는 사용자는 자신의 시간을 덜 소비하여 운영 비용을 절감해야합니다. 시스템을 개발하고 자체적으로 호스팅하는 것과 동등합니다.

그러나 이 이점은 IaaS (Infrastructure as a Service) 또는 PaaS (Platform as a Service)에서 얻을 수있는 이점과 크게 다르지 않습니다. 그러나 우리는 Serverless BaaS 및 FaaS 각각에 대해 두 가지 주요 방법으로이 이점을 확장 할 수 있습니다.

### BaaS - reduced development cost

IaaS 및 PaaS는 서버 및 운영 체제 관리가 범용화 될 수 있다는 전제에 기반합니다. 반대로 서버없는 백엔드 서비스는 전체 응용 프로그램 구성 요소가 범용화 된 결과입니다.

인증은 좋은 예입니다. 많은 애플리케이션은 가입, 로그인, 비밀번호 관리, 다른 인증 제공 업체와의 통합 등과 같은 기능을 포함하는 자체 인증 기능을 코딩합니다. 전체적으로 이 로직은 대부분의 애플리케이션에서 매우 유사하므로 Auth0과 같은 서비스가 생성되었습니다 우리가 스스로 개발할 필요없이 우리가 준비된 인증 기능을 애플리케이션에 통합 할 수있게 해줍니다.

Firebase의 데이터베이스 서비스와 같은 BaaS 데이터베이스가 동일한 스레드에 있습니다. 일부 모바일 응용 프로그램 팀은 클라이언트가 서버 측 데이터베이스와 직접 통신하게하는 것이 합리적임을 발견했습니다. BaaS 데이터베이스는 많은 데이터베이스 관리 오버 헤드를 없애고 일반적으로 서버리스 (Serverless) 애플리케이션에서 예상되는 패턴으로 다양한 유형의 사용자에게 적절한 승인을 제공하는 메커니즘을 제공합니다.

귀하의 배경에 따라 이러한 아이디어를 모두 엿먹일 수 있습니다(단점이있는 부분에 대해서는 걱정하지 마십시오!) 간신히 자신의 서버 측 코드가 포함 된 강력한 제품을 생산할 수 있었던 성공적인 기업의 수를 부정하는 것은 아닙니다. Joe Emison은 최근의 Serverless Conference에서 두 가지 예를 들었습니다.

### FaaS - scaling costs

serverless FaaS의 즐거움 중 하나는 필자가 이 기사의 앞 부분에서 말했듯이 '수평 확장은 완전히 자동적이고 탄력적이며 공급자가 관리합니다'. 여기에는 몇 가지 이점이 있지만 기본 인프라 측면에서 가장 큰 이점은 AWS Lambda의 경우 100ms 경계까지 필요한 계산에 대해서만 비용을 지불한다는 것입니다. 트래픽 규모와 모양에 따라 이것은 경제적으로 큰 승리 일 수 있습니다.

#### Example - occasional requests

예를 들어 매분 1 회의 요청 만 처리하는 서버 응용 프로그램을 실행 중이며 각 요청을 처리하는 데 50 밀리 초가 걸리며 평균 CPU 사용량은 1 시간 동안 0.1 %라고 가정합니다. 한 가지 관점에서 이것은 비효율적입니다. 1000 개의 다른 응용 프로그램이 CPU를 공유 할 수 있다면 동일한 컴퓨터에서 작업 할 수 있습니다.

Serverless FaaS는 이러한 비효율을 포착하여 비용을 절감하면서 혜택을 제공합니다. 이 시나리오에서는 매분 100ms 만 지불하면되므로 전체 시간의 0.15 %입니다.

이것은 다음과 같은 노크 - 온 이점을 가지고있다 :

- 매우 작은로드 요구 사항을 갖는 마이크로 서비스의 경우, 미세 단위의 운영 비용이 엄청나게 높을지라도 로직 / 도메인별로 구성 요소를 분해하는 지원을 제공합니다.
- 이러한 비용 절감은 훌륭한 민주주의 자입니다. 회사나 팀이 새로운 것을 시험해보고자 할 때, FaaS를 컴퓨팅 요구에 사용할 때 '물속에 발을 살짝 담그는 것'과 같이 관련된 운영 비용이 극히 적습니다. 
- 실제로 전체 워크로드가 상대적으로 작지만 (전체적으로 중요하지 않은 경우) 일부 FaaS 공급 업체가 제공하는 '무료 티어'로 인해 계산에 대한 비용을 전혀 지불하지 않아도됩니다.

#### Example - inconsistent traffic

다른 예를 살펴 보겠습니다. 트래픽 프로필이 매우 '스파이키(spikey)'라고 가정 해보십시오. - 기본 트래픽은 초당 20 요청이지만 5 분마다 초당 200 회의 요청 (보통 수의 10배)을 10 초 동안받습니다. 기본 성능이 원하는 서버를 최대한으로 사용하고 트래픽 스파이크 단계에서 응답 시간을 줄이려하지 않는다고 가정 해 봅시다. 예를 들어 기본 성능이 기본 설정 서버를 최대한으로 사용한고, 트래픽 스파이크 단계에서 응답 시간을 줄이려는 것이 아니라고 가정해봅시다. 어떻게 이것을 해결할 수 있습니까?

일반적인 환경에서는 총 시스템 가동 시간의 4 % 미만 만 차지하더라도 스파이크를 처리하려면 총 하드웨어 용량을 10 배로 늘려야합니다. 새 인스턴스가 부팅 될 때까지 서버의 새로운 인스턴스를 가져 오는 데 걸리는 시간이 길어지기 때문에 자동 크기 조정은 좋은 옵션이 아닙니다.

![spikey](https://martinfowler.com/articles/serverless/inconsistent-traffic-pattern.png)

그러나 Serverless FaaS를 사용하면 이것이 문제가 되지 않습니다. 말 그대로 트래픽 프로필이 일정한 경우와 다르게 스파이크 단계에서 추가 컴퓨팅 용량을 지불하여 처리합니다. 

분명히 Serverless FaaS가 엄청난 비용 절감 효과를 가져다 주었던 점을 분명히 여기에서 골랐지만 요컨대 요즘은 FaaS를 사용하여 돈을 절약 할 수있는 정수의 서버 시스템을 지속적으로 사용하는 트래픽이 일정하지 않으면 스케일링 관점에서.

분명히 Serverless FaaS가 엄청난 비용 절감 효과를 가져다주는 예를 고의로 여기에서 골랐으나, 요점은 일관된 숫자의 서버 시스템을 일관되게 사용하는 매우 안정적인 트래픽 형태에서가 아닌 순전히 스케일링 관점에서 FaaS를 사용하여 비용을 절감 할 수 있다는 것입니다.

위의 사항에 대한 한 가지 주의 사항 - 트래픽이 균일하고 지속적으로 실행중인 서버를 효율적으로 활용한다면 이 비용상의 이점을 볼 수 없으며 실제로 FaaS를 사용하여 더 많은 비용을 지출 할 수 있습니다. 현재 공급 업체 비용과 실행중인 풀 타임 서버의 비용을 비교하여 비용이 수용 가능한지 여부를 확인해야합니다.

#### Optimization is the root of some cost savings(최적화는 비용 절감의 근원입니다.)

FaaS 비용에는 흥미로운 점이 하나 더 있습니다. - 코드에 대한 성능 최적화를 통해 앱의 속도가 향상 될뿐만 아니라 공급 업체의 요금 체계가 세분화되어 운영 비용이 절감 될 수 있습니다. 예를 들어, 각 작업에 현재 1 초가 걸리고 200ms로 줄이면 인프라 변경없이 즉시 컴퓨팅 비용이 80 % 절감됩니다.

### Easier Operational Management(더 쉬운 운영 관리)

이 섹션에는 거대한 별표가 붙습니다. Serverless에서는 아직 몇 가지 작업이 어렵습니다. 그러나 지금은 새로운 유니콘과 레인보우 친구들과 함께하고 있습니다.

울타리의 Serverless BaaS 측면에서 운영 관리가 다른 아키텍처보다 더 단순한 이유는 상당히 분명한 사실입니다. 지원하는 구성 요소가 적어 작업량이 적습니다.

FaaS 측면에는 여러 측면이 있지만 나는 그 중 몇 가지를 파헤칩니다.

#### Scaling benefits of FaaS beyond costs(FaaS의 이점을 비용 이상으로 확장)

이전 섹션에서 스케일링이 새롭지만, FaaS의 스케일링 기능은 컴퓨팅 비용을 줄여 줄뿐만 아니라 스케일링이 자동이기 때문에 운영 관리를 감소시킵니다.

가장 좋은 경우는, 스케일링 프로세스를 수동적으로 할 때, 예를 들어 사람이 직접 명시적으로 인스턴스를 서버 배열에 추가하고 제거하고자 할때, FaaS가 이런 것들을 잊게 해줘서 너는 행복해할 것이고, FaaS 공급 업체가 응용 프로그램을 확장 할 것이다.

FaaS가 아닌 아키텍처에서 '자동 크기 조정'을 사용하는 경우에도 여전히 설정 및 유지 관리가 필요합니다. - 이 작업은 FaaS에서 더 이상 필요하지 않습니다.

마찬가지로 모든 요청 / 이벤트가 있을 때마다 공급자가 확장을 수행하기 때문에 더 이상 메모리 부족하거나 성능에 너무 많은 부분을 처리하기 전에 처리할 수 있는 동시 요청 수에 대한 질문을 고려하지 않아도 됩니다. 또는 성능 저하가 발생하기 전에 처리 할 수있는 동시 요청 수에 대한 질문을 고려하지 않아도됩니다. 적어도 FaaS가 호스팅하는 구성 요소에는 포함되지 않습니다. 다운 스트림 데이터베이스 및 비 FaaS 구성 요소는 부하가 크게 증가 할 수 있다는 관점에서 재검토되어야합니다.

#### Reduced packaging and deployment complexity(패키징 및 배포의 복잡성 감소)

API 게이트웨이는 아직 간단하지 않지만 FaaS 기능을 패키징하고 배포하는 작업은 전체 서버를 배포하는 것과 비교하여 매우 간단합니다. 당신이하고있는 일은 코드를 컴파일하고 ziping / jar'ing 한 다음 업로드하는 것뿐입니다. puppet / chef가 없고, 시작 / 중지 셸 스크립트가 없으며 컴퓨터에 하나 또는 여러 개의 컨테이너를 배포할지 여부는 결정되지 않습니다. 시작하기 만하면 아무것도 패키징 할 필요가 없습니다. 공급 업체 콘솔에서 직접 코드를 작성할 수 있습니다 (프로덕션 코드에는 권장되지 않습니다).

이것은 설명하는 데 오랜 시간이 걸리지 않지만 일부 팀에서는 이러한 이점이 절대적으로 커질 수 있습니다. 완벽한 서버리스 솔루션을 사용하려면 시스템 관리가 필요 없습니다.

PaaS (Platform-as-a-Service) 솔루션은 배포 이점이 비슷하지만 이전에 PaaS를 FaaS와 비교했을 때 FaaS만의 확장 이점이 있습니다.

#### Time to market / experimentation

'보다 쉬운 운영 관리'는 엔지니어가 이해하는 이점이지만 비즈니스에 미치는 영향은 무엇입니까?

분명한 경우는 비용입니다. 운영 시간은 짧고 운영에 필요한 인력은 적습니다. 그러나 훨씬 더 중요한 사례는 '시장 출시'입니다. 우리 팀과 제품이 기댈 수있는 민첩한 프로세스를 중심으로 점차 증가함에 따라 우리는 끊임없이 새로운 것을 시도하고 기존 시스템을 빠르게 업데이트하려고합니다. 간단한 재배포로 안정적인 프로젝트를 신속하게 반복 할 수 있지만 새로운 아이디어 - 초기 전개 기능을 통해 적은 마찰과 최소한의 비용으로 새로운 실험을 시도 할 수 있습니다.

FaaS에 대한 새로운 아이디어 - 초기 배포 이야기는 경우에 따라, 특히 공급 업체의 생태계에서 성숙 된 정의 이벤트에 의해 트리거되는 단순한 기능에 대해 우수합니다. 예를 들어 조직에서 인프라를 통해 다양한 유형의 실시간 이벤트를 방송하기 위해 Kafka와 유사한 메시징 시스템 인 AWS Kinesis를 사용한다고 가정 해보십시오. AWS Lambda를 사용하면 단 몇 분만에 Kinesis 스트림에 대한 새로운 제작 이벤트 리스너를 개발하고 배포 할 수 있습니다. 하루에 여러 가지 실험을 시도 할 수 있습니다!

웹 기반 API의 경우 대부분의 경우 아직 동일하지는 않지만 다양한 오픈 소스 프로젝트와 소규모 구현이 앞장서고 있습니다. 나중에 더 자세히 논의하겠습니다.

### ‘Greener’ computing?(친환경 컴퓨팅)

지난 수십 년 동안 전세계 데이터 센터의 규모와 크기가 폭발적으로 증가했으며 이와 함께 많은 에너지, 서버 및 네트워크 스위치를 구축하는 데 필요한 다른 모든 물리적 자원도 함께 사용되었습니다. Apple, Google 등은 재생 가능 에너지 원 근처에서 데이터 센터 일부를 호스팅하여 해당 사이트의 화석 연료 연소 영향을 줄이는 방법에 대해 이야기합니다.

이러한 엄청난 성장의 이유 중 하나는 유휴 상태이지만 전원이 켜져있는 서버의 수입니다.

> 비즈니스 및 엔터프라이즈 데이터 센터의 일반적인 서버는 연간 최대 평균 컴퓨팅 출력의 5 ~ 15 %를 제공합니다. --포브스

이는 비효율적이며 환경에 막대한 영향을줍니다.

한편으로는 클라우드 인프라가 도움이되었을 가능성이 높습니다. 기업들은 필요한 모든 서버를 사전에 장기간 제공하지 않고 필요에 따라 더 많은 서버를 '구매할 수 있기 때문입니다. 그러나 서버를 쉽게 프로비저닝하면 많은 용량의 서버가 적절한 용량 관리없이 방치되는 경우 상황이 악화 될 수 있다고 주장 할 수 있습니다.

자체 호스팅, IaaS 또는 PaaS 인프라 솔루션 사용 여부에 관계없이 수개월 또는 수년간 계속 될 애플리케이션에 대한 용량 결정을 내리고 있습니다. 일반적으로 용량과 초과 공급을 관리하는 것에 대해서는 신중해야하며 적절하게 설명하면 비효율적입니다. Serverless 접근법을 통해 우리는 더 이상 그러한 용량 결정을 스스로하지 않습니다. - 우리는 Serverless 공급 업체가 우리의 요구에 맞는 충분한 컴퓨팅 용량을 실시간으로 제공 할 수있게했습니다. 그런 다음 공급 업체는 고객에 대해 자체적으로 용량 결정을 내릴 수 있습니다.

이러한 차이는 기존의 용량 관리 방식에 비해 환경 영향을 줄이면서 데이터 센터 전반에 걸쳐 자원을 훨씬 더 효율적으로 사용하게합니다.

## Drawbacks

소중한 독자 여러분, 무지개와 유니콘, 그리고 반짝 반짝 빛나는 모든 것들을 즐기십시오. 현실의 젖은 물고기가 얼굴 주위를 때리는 것처럼 추악 해지기 시작했기 때문입니다.

Serverless 아키텍처에 대해 좋아할만한 점이 많습니다. 많은 약속이 있다고 생각하지 않는다면 시간을 낭비하지 않아도되지만 상당한 트레이드 오프가 있습니다. 이 중 일부는 개념에 내재되어 있습니다. 진보에 의해 완전히 고쳐질 수는 없으며 항상 고려해야 할 것입니다. 다른 것들은 현재의 구현으로 내려 가고 있으며 시간이 지나면 해결 된 것을 볼 수있을 것입니다.

### Inherent Drawbacks

#### Vendor control

아웃소싱 전략을 사용하면 일부 시스템을 타사 공급 업체에 제공하는 것을 포기합니다. 이러한 제어 불능은 시스템 다운 타임, 예기치 않은 한계, 비용 변경, 기능 손실, 강제 API 업그레이드 등으로 나타날 수 있습니다. 앞서 언급 한 Charity Majors는 이 기사의 트레이드 오프 섹션에서 이 문제에 대해 자세히 설명합니다.

> [공급 업체 서비스]는 똑똑하고, 당신이 그것을 어떻게 사용할 수 있는지에 대해 강한 제약을 가할 것이기 때문에, 그들은 그들의 신뢰성 목표를 달성 할 가능성이 더 크다. 사용자가 융통성과 선택권을 가지고있을 때 그것은 혼란과 신뢰할 수없는 것을 만듭니다. 플랫폼이 당신의 행복과 수천 명의 다른 고객의 행복 사이에서 선택해야한다면, 매 시간마다 많은 것을 선택할 것입니다.  -- Charity Majors

#### Multitenancy Problems

다중 테넌트 (Multitenancy)는 여러 고객 을 위한 여러 개의 실행중인 소프트웨어 인스턴스가 동일한 시스템에서, 그리고 동일한 호스팅 애플리케이션에서 실행되는 상황을 나타냅니다. 앞서 언급한 규모의 경제를 달성하는 전략입니다. 서비스 공급 업체는 자신의 시스템을 사용하는 유일한 사람들이라는 느낌을주기 위해 애써 노력하고 있습니다. 일반적으로 훌륭한 서비스 공급 업체는 훌륭한 업무를 수행합니다. 그러나 완벽하지 않고 때로는 다중 점유 솔루션은 보안 (한 고객이 다른 고객의 데이터를 볼 수 있음), 견고성 (한 고객의 소프트웨어가 다른 고객의 소프트웨어에서 오류를 일으키는 오류) 및 성능(고 부하 고객이 다른 제품을 늦추는 원인)으로 인해 문제를 겪을 수 있습니다.

이러한 문제는 서버리스 시스템에만 국한된 것이 아니며 멀티 테넌시를 사용하는 많은 다른 서비스 제품에 존재합니다. 그러나 많은 서버리스 시스템이 새로 도입되어 이제는 이러한 시스템이 성숙 해지면 더 많은 유형의 문제가 발생할 것으로 예상됩니다.

#### Vendor lock-in

여기 Serverless 공급 업체와 관련된 세 번째 문제가 있습니다. lock-in. 벤더에서 사용하는 Serverless 기능이 다른 공급 업체에 의해 다르게 구현 될 가능성이 매우 높습니다. 운영 도구 를 업데이트해야하는 공급 업체를 전환하려면 코드를 변경해야합니다 (예 : 다른 FaaS 인터페이스를 충족해야 함). 경쟁 업체의 구현 방식과 다른 점이 있다면 디자인이나 아키텍처를 변경하십시오.

여기 Serverless 공급 업체와 관련된 세 번째 문제가 있습니다. 잠금 기능. 벤더에서 사용하는 Serverless 기능이 다른 공급 업체에 의해 다르게 구현 될 가능성이 매우 높습니다. 거의 확실하게 운영 도구(배포, 모니터링 등)를 업데이트해야하는 공급 업체를 변경하려면 코드를 변경해야 할 수 있으며(예를 들어, 상이한 FaaS 인터페이스를 만족시키기 위해), 경쟁 업체의 구현 방식과 다른 점이 있다면 디자인이나 아키텍처를 변경해야 할 수도 있습니다.

생태계의 한 부분에 대해 이 작업을 수행 할 수 있다고 하더라도 다른 아키텍처 구성 요소로 인해 잠겨있을 수 있습니다. 예를 들어, AWS Lambda를 사용하여 AWS Kinesis 메시지 버스의 이벤트에 응답한다고 가정해 보겠습니다. AWS Lambda, Google Cloud Functions 및 Microsoft Azure Functions의 차이점은 비교적 적지만 후자의 2개 공급 업체 구현을 직접 AWS Kinesis 스트림에 직접 연결할 수는 없습니다. 즉, 한 솔루션에서 다른 솔루션으로 코드를 이동하거나 이식하는 것은 인프라의 다른 부분도 이동하지 않으면 불가능합니다.

그리고 마침내 다른 공급 업체의 기능으로 시스템을 다시 구현하는 방법을 찾더라도 공급 업체가 제공하는 것에 따라 마이그레이션 프로세스를 계속 수행하게됩니다. 예를 들어 1 BaaS 데이터베이스에서 다른 BaaS 데이터베이스로 전환하는 경우 원본 및 대상 공급 업체의 내보내기 및 가져 오기 기능으로 원하는 작업을 수행 할 수 있습니까? 그리고 비록 그들이 비용과 노력의 어느 정도의 금액으로?

이 중 일부에 대한 가능한 완화책 중 하나는 다중 Serverless 공급 업체의 신흥 일반 추상화 일 수 있으며 나중에 더 자세히 논의 할 것입니다.

#### Security concerns

이는 실제로 기사 자체만으로는 충분하지만 Serverless 접근 방식을 채택하면 많은 보안 질문을 할 수 있습니다. 이들 중 두 가지는 다음과 같지만 고려해야 할 다른 것들이 많이 있습니다.

- 사용하는 각각의 서버리스 벤더만큼 생태계에 수용된 다양한 보안 구현의 수가 증가합니다. 이로 인해 악의적 인 의도와 공격의 성공 가능성이 높아집니다.
- 모바일 플랫폼에서 직접 BaaS 데이터베이스를 사용하는 경우, 전통적인 어플리케이션에서 서버 응용 프로그램이 제공하는 보호 장벽을 잃어 가고 있습니다. 이것은 거래가 아니지만 응용 프로그램을 설계하고 개발할 때 상당한주의가 필요합니다.

#### Repetition of logic across client platforms(클라이언트 플랫폼에 걸친 로직 반복)

'전체 BaaS'아키텍처에서는 사용자 지정 논리가 서버 측에 쓰여지지 않습니다. 모든 것이 클라이언트에 있습니다. 이는 첫 번째 클라이언트 플랫폼에서 유용 할 수 있지만 다음 플랫폼이 필요할 때보다 전통적인 아키텍처에서 수행하지 않았던 로직의 하위 집합 구현을 반복해야 할 것입니다. 예를 들어 이러한 종류의 시스템에서 BaaS 데이터베이스를 사용하는 경우, 모든 클라이언트 응용 프로그램(웹, 기본 iOS 및 기본 Android)이 이제 공급 업체 데이터베이스와 통신 할 수 있어야하고 데이터베이스 스키마에서 응용 프로그램 논리로 매핑하는 방법을 이해해야합니다.

또한 언제든지 새 데이터베이스로 마이그레이션하려는 경우, 다른 모든 클라이언트에서도 코딩 / 코디네이션 변경 사항을 복제해야합니다.

#### Loss of Server optimizations

다시 '풀 BaaS'아키텍처로 클라이언트 성능을 위해 서버 설계를 최적화 할 수있는 기회는 없습니다. 'backend for frontend'패턴은 서버 내에서 전체 시스템의 특정 기본 요소를 추상화하는 데 사용됩니다. 일부는 클라이언트가 모바일 애플리케이션의 경우보다 신속하게 작업을 수행하고 배터리 전원을 덜 소모 할 수 있습니다. 이러한 패턴은 '전체 BaaS'에는 사용할 수 없습니다.

#### No in-server state for Serverless FaaS(Serverless FaaS에 대한 서버 내 상태 없음)

몇 가지 BaaS 관련 단점들이 잠시 FaaS에 대해 이야기 해 봅니다. 나는 이전에 말했다.:

> FaaS 기능은 로컬 .. 상태와 관련하여 상당한 제한이 있습니다. .. 함수를 호출 할 때 어떤 in-process 또는 호스트 상태도 후속 호출에서 사용할 수 없다고 가정해야합니다.

나는 또한 이것에 대한 대안이 바로이 제약을 받아들이는 'Twelve Factor App'의 요인 6을 따르는 것이라고 말했다.

> 12 요소 프로세스는 무상태이며 공유가 없습니다. 지속되어야하는 데이터는 일반적으로 스테이트 풀 백킹 서비스 (예 : 데이터베이스)에 저장해야합니다. ---- The Twelve-Factor App

Heroku는 이런 사고 방식을 권장하지만 PaaS를 실행할 때 규칙을 조금 봐줄수는 있습니다. 하지만, FaaS는 반드시 지켜야 합니다.

만약 메모리에 상태를 유지할 수 없다면, 상태는 FaaS의 어디로 가게됩니까? 위의 인용문은 데이터베이스를 사용하는 것을 말하며 대부분의 경우 빠른 NoSQL 데이터베이스, 프로세스 외 캐시 (예 : Redis) 또는 외부 파일 저장소 (예 : S3)가 옵션 중 일부입니다. 그러나 이것들은 메모리 내 또는 기계 내 지속성보다 훨씬 느립니다. 당신은 당신의 어플리케이션이 여기에 적합한지 고려해야할 것입니다.

이와 관련하여 또 다른 문제는 메모리 내 캐시입니다. 외부에 저장된 큰 데이터 세트에서 읽는 많은 앱은 해당 데이터 세트의 일부에 대한 메모리 내 캐시를 유지합니다. 데이터베이스의 '참조 데이터'테이블을 읽고 Ehcache와 같은 것을 사용할 수 있습니다. 또는 캐시 헤더를 지정하는 http 서비스에서 읽을 수 있습니다.이 경우 사용자의 in-memory http 클라이언트가 로컬 캐시를 제공 할 수 있습니다. FaaS 구현을 사용하면 앱에 이 코드를 포함 할 수 있지만 캐시가 거의 도움이되지는 않습니다. 첫 번째 사용에서 캐시가 'warmed up'되는 즉시 FaaS 인스턴스가 제거됨에 따라 캐시가 폐기 될 수 있습니다.

이것에 대한 완화는 더 이상 In-Process 캐시를 가정하지 않고 Redis 또는 Memcached와 같은 대기 시간이 짧은 외부 캐시를 사용하지만, (a) 추가 작업이 필요하며 (b) 사용 사례에 따라 너무 느려질 수도 있습니다.

### Implementation Drawbacks

앞에서 설명한 단점은 Serverless에서 항상 존재할 가능성이 있습니다. 해결책을 완화하는 데있어 개선점을 확인할 수 있지만 항상 존재할 것입니다.

그러나, 나머지 단점은 순수하게 현재의 최첨단 수준에 미치지 못한다. 벤더나 heroic community에 대한 성향과 투자로 이들은 모두 사라질 수 있습니다. 하지만 지금 당장은 약간의 두자(doozies)가 있습니다 ...

#### Configuration

AWS 람다 함수는 설정을 제공하지 않습니다. 없음. 환경 변수조차도 없습니다. 환경의 특성에 따라 다른 특성을 가진 동일한 배포 아티팩트를 어떻게 실행합니까? 당신은 할 수 없습니다. 다른 임베디드 구성 파일을 사용하여 배포 아티팩트를 다시 정의해야합니다. 이것은 추한 해킹입니다(This is an ugly hack). Serverless 프레임 워크는 이러한 해킹을 추상화 할 수 있지만 여전히 해킹입니다(The Serverless framework can abstract this hack for you, but it’s still a hack.).

나는 아마존이 이것을 고치고 있다고(아마도 곧) 믿을만한 이유가 있으며, 다른 벤더들이 같은 문제를 겪고 있는지 알지 못하지만, 지금 당장이 많은 것들이 출혈(bleeding edge)을 일으키는 이유의 예가 바로 위에서 언급됩니다.

#### DoS yourself

지금은 FaaS를 다룰 때마다 Caveat Emptor가 중요한 문구 인 이유에 대한 또 다른 재미있는 예가 있습니다. 현재 AWS Lambda는 모든 람다를 동시에 실행할 수있는 실행 횟수를 제한합니다. 이 제한이 1000이라고하면, 언제든지 1000 개의 함수를 실행할 수 있다는 것을 의미합니다. 무언가가 위에 올라야 할 필요가 생기면 예외가 생기기 시작하고 대기열(큐잉)에 넣고 일반 속도가 느려질 수 있습니다.

여기서 문제는 이 한도가 전체 AWS 계정에 있다는 것입니다. 일부 조직에서는 생산 및 테스트에 동일한 AWS 계정을 사용합니다. 즉, 조직의 누군가가 새로운 유형의로드 테스트를 수행하고 1000 개의 동시 람다 (Lambda) 기능을 실행하기 시작하면 우연히 운영 애플리케이션을 DoS합니다. 웁스.

생산 및 개발을 위해 다른 AWS 계정을 사용하더라도 과부하 된 생산 람다 (예 : 고객의 배치 업로드 처리)가 있으면 실시간 람다 지원 생산 API가 응답하지 않을 수 있습니다.

다른 유형의 AWS 자원은 다양한 보안 및 방화벽 개념을 통해 환경 및 응용 프로그램 영역의 컨텍스트로 구분할 수 있습니다. 람다는 똑같은 것을 필요로 합니다. 그리고 나는 그것이 너무 오래 전에 의심 할 여지가 없습니다. 그러나 지금 당장은 다시주의하십시오.

#### Execution Duration

앞서 기사에서 AWS Lambda 함수가 5 분 이상 실행되면 중단된다는 점을 언급했습니다. 그것이 내가 나중에 제거 할 수 있다고 예상 할 수있는 한계이지만 AWS가 어떻게 접근하는지 보는 것은 흥미로울 것입니다.

#### Startup Latency

앞서 언급한 또 다른 관심사는 FaaS 함수가 응답하는 데 걸리는 시간입니다. AWS에서 가끔씩 사용되는 JVM 구현 함수의 경우 특히 그렇습니다. 이러한 람다 함수를 사용하면 시작하는 데 10 초 정도 걸릴 수 있습니다.

AWS는 시간이 지남에 따라 이를 개선하기 위한 다양한 완화 방법을 구현할 것으로 기대하지만 현재로서는 특정 사용 사례에서 JVM Lambdas를 사용하는 데있어 대폭적인 단점이 될 수 있습니다.

AWS Lambda를 충분히 따를 수 있습니다. 다른 공급 업체들도 간신히 옷장에 꽤 못생긴 뼈대를 가지고있을 것이라고 확신합니다.

#### Testing

단위 테스트 Serverless Apps는 제가 이전에 얘기 한 이유 때문에 상당히 간단합니다. - 작성한 코드는 '단순한 코드'이며 구현해야하는 커스텀 라이브러리 나 인터페이스가 대부분이 아닙니다.

반면에 Serverless Apps 통합 테스트는 어렵습니다. BaaS 세계에서 의도적으로 (예를 들어) 자신의 데이터베이스보다는 외부 제공 시스템에 신중하게 의존하고 있습니다. 통합 테스트에서도 외부 시스템을 사용해야합니까? 그렇다면 테스트 시나리오에 해당 시스템이 얼마나 적합합니까? 쉽게 찢어 지거나 찢어지기 쉬운 상태일까요? 공급 업체가 부하 테스트를위한 다른 청구 전략을 제공 할 수 있습니까?

통합 테스트를 위해 외부 시스템을 스텁링하려면 공급 업체가 로컬 스텁 시뮬레이션을 제공합니까? 그렇다면 스텁의 충실도는 얼마나 좋은가? 공급 업체가 스텁을 제공하지 않으면 어떻게 구현합니까?

FaaS-land에도 같은 종류의 문제가 있습니다. 현재 대부분의 공급 업체는 사용할 수 있는 로컬 구현을 제공하지 않으므로 일반 프로덕션 구현을 사용해야합니다. 그러나 이것은 원격으로 배치하고 모든 통합 / 승인 테스트를 위해 원격 시스템을 사용하여 테스트하는 것을 의미합니다. 더 나쁜 것은 방금 설명한 종류의 문제(설정 없음(no configuration), 교차 계정 실행 제한(cross-account execution limits))가 테스트하는 방법에 영향을 미칠 것입니다.

이것이 큰 이유 중 하나는 Serverless FaaS (즉, 각 function)와의 통합 단위가 다른 아키텍처보다 훨씬 작기 때문에 우리는 다른 아키텍처 스타일보다 훨씬 더 많은 통합 테스트에 의존한다는 것입니다.

Tim Wagner (AWS Lambda의 제너럴 매니저)는 최근 Serverless Conference에서 테스트에 착수하고 있다고 말했지만, 클라우드 테스트에 크게 의존 할 것처럼 보였습니다. 이것은 아마도 용감한 새로운 세계 일 것입니다.하지만 필자의 랩탑에서 오프라인으로 시스템을 완전히 테스트 할 수는 없을 것입니다.

#### Deployment / packaging / versioning

이것은 FaaS 특정 문제입니다. 지금 우리는 일련의 기능을 애플리케이션에 묶는 좋은 패턴을 놓치고 있습니다. 이는 몇 가지 이유로 인해 문제가됩니다.

- 전체 논리 응용 프로그램의 모든 기능에 대해 FaaS 이슈를 별도로 배포해야 할 수 있습니다. 응용 프로그램이 JVM에 구현되고 20 개의 FaaS 기능이 있으면 JAR을 20 번 배포하는 것을 의미합니다.
- 또한 함수 그룹을 원자 적으로 배포할 수 없음을 의미합니다. 함수를 트리거하는 이벤트 원본을 해제하고, 전체 그룹을 배포 한 다음, 이벤트 원본을 다시 켜야 할 수 있습니다. 이는 다운 타임이없는 응용 프로그램에서 문제가 됩니다.
- 마지막으로, 버전이있는 응용 프로그램의 개념이 없으므로 원자 롤백(atomic rollback)은 옵션이 아닙니다.

이 중 일부를 돕기위한 오픈 소스 해결책이 있지만 벤더 지원을 통해서만 제대로 해결할 수 있습니다. AWS는 최근의 Serverless Conference에서 이러한 우려 사항 중 일부를 해결하기 위해 'Flourish'라는 새로운 계획을 발표했지만 아직 구체적인 내용은 공개하지 않았습니다.

#### Discovery

구성 및 패키징과 관련된 부분과 마찬가지로 FaaS 기능 전반에 걸친 discovery 패턴도 잘 정의되어 있지 않습니다. 이 중 일부는 FaaS의 특정 기능이 아니지만 FaaS 기능의 세부적인 특성과 응용 프로그램 / 버전 지정 정의의 부족으로 인해 문제가 악화됩니다.

#### Monitoring / Debugging

현재는 공급 업체가 제공하는 모니터링 및 디버깅을 사용해야합니다. AWS Lambda의 경우 매우 베이직하기 때문에, 어떤 경우는 괜찮을 수 있습니다. 이 분야에서 우리가 정말로 필요로하는 것은 오픈 API와 제 3 자 서비스가 도움을 줄 수있는가에 대한 능력입니다.

#### API Gateway definition, and over-ambitious API Gateways

최근 ThoughtWorks Technology Radar는 ![over-ambitious API 게이트웨이](https://www.thoughtworks.com/radar/platforms/over-ambitious-api-gateways)에 대해 논의했습니다. 해당 링크는 일반적인 API 게이트웨이를 언급하지만, 이전에 언급했듯이 특히 FaaS API 게이트웨이에 분명히 적용할 수 있습니다. 문제는 API 게이트웨이가 그들 자신의 특정 구성 / 정의된 도메인 내에서 많은 응용 프로그램의 특정 논리를 수행 할 수있는 기회를 제공한다는 것입니다. 이 로직은 일반적으로 테스트하기 어렵고, 버전 관리가 어렵고, 심지어 매번 정의하기도합니다. 그러한 로직은 나머지 응용 프로그램과 같이 프로그램 코드에 남아있게하는 것이 훨씬 더 좋습니다.

현재 Amazon의 API 게이트웨이를 사용하면 가장 단순한 애플리케이션에서도 게이트웨이 관련 개념과 구성 영역을 많이 사용해야합니다. 이것은 부분적으로 개발자가 구현 관련 개념을 추상화하고 일반 코드를 사용하도록 허용하기 위해 Serverless 프레임 워크 및 Claudia.js와 같은 오픈 소스 프로젝트가 존재하는 이유입니다.

API 게이트웨이를 과도하게 복잡하게 만들 가능성은 언제나 있지만, 우리는 그렇게하지 않아도되는 툴링과 그러한 함정에서 벗어나도록 도와 줄 수있는 패턴을 볼 것으로 기대해야합니다.

#### Deferring of operations

앞서 언급 한 Serverless는 'No Ops'가 아닙니다. - 모니터링, 아키텍처 확장, 보안, 네트워킹 등의 관점에서 볼 때 여전히 많은 것들이 있습니다. 그러나 Serverless가 'No Ops'라고 묘사 한 사실은 사용자가 시작할 때 작업을 무시하는 것이 쉽다는 사실에서 비롯됩니다. - “Look ma - 운영 체제가 없습니다!" 여기서의 위험은 거짓된 안보 감각에 빠지게됩니다. 어쩌면 앱을 정상적으로 실행했지만 Hacker News에 예기치 않게 나타 났을 수 있습니다. 갑자기 10 배나되는 트래픽이 발생하여 실수로 DoS가 발생하고이를 처리하는 방법을 모릅니다.

위의 API 게이트웨이 지점과 마찬가지로 여기에있는 수정 사항은 교육입니다. 서버리스 시스템을 사용하는 팀은 운영 활동을 조기에 고려할 필요가 있으며 벤더와 커뮤니티는 이것이 의미하는 바를 이해하는 데 도움이되는 교육을 제공합니다.

## The Future of Serverless

우리는 Serverless 아키텍처 세계로의 여정을 끝내고 있습니다. 결론을 내리기 위해 나는 Serverless 세계가 앞으로 수개월에 걸쳐 발전 할 것이라고 생각하는 몇 가지 영역에 대해 논의 할 것입니다.

### Mitigating the Drawbacks(단점 완화)

이미 여러 번 언급 한 것처럼 Serverless는 새로운 것입니다. 그리고 이전의 단점 섹션은 광범위했으며 필자가 가질 수있는 모든 것을 다루지 않았습니다. Serverless의 가장 중요한 발전은 고유 한 단점을 완화하고 구현상의 단점을 없애거나 적어도 개선하는 것입니다.

#### Tooling

Serverless FaaS의 가장 큰 문제점은 바로 툴링입니다. 배포 / 응용 프로그램 번들링, 구성, 모니터링 / 로깅 및 디버깅은 모두 심각한 작업이 필요합니다.

Amazon의 발표되었지만 아직 구체화되지 않은 Flourish 프로젝트는 이들 중 일부를 도울 수 있습니다. 발표의 또 다른 긍정적 인 부분은 그것이 오픈 소스가 될 것이고, 벤더 간의 애플리케이션 이식성의 기회를 제공한다는 것입니다. 오픈 소스 세계에서 내년 1, 2 년 동안 발전해 나갈 것이라고 기대합니다.

모니터링, 로깅 및 디버깅은 모두 공급 업체 구현의 일부이며 여기서 BaaS 및 FaaS의 개선점을 확인할 수 있습니다. AWS에서의 로깅 Lambda는 ELK 등을 사용하는 기존 앱과 비교해 볼 때 적어도 당황 스럽습니다. 우리는이 분야 (예 : IOPipe 및 lltrace-aws-sdk)에서 타사의 상용 및 오픈 소스 노력의 초기를 보았습니다. 그러나 우리는 New Relic의 범위에서 멀리 떨어져 있습니다. 내 희망은 AWS가 FaaS를위한 더 나은 로깅 솔루션을 제공하는 것 말고는 Heroku 및 다른 사람들과 동일한 방식으로 제 3 자 로깅 서비스에 쉽게 연결할 수 있기를 바랍니다.

API 게이트웨이 도구는 또한 대규모 개선이 필요하며, 일부는 Flourish 또는 Serverless Framework 등의 발전으로 인해 발생할 수 있습니다.

#### State Management

FaaS에 대한 서버 내부 상태의 부족은 많은 수의 애플리케이션에서 문제가되지 않지만 많은 다른 애플리케이션에서 거래 차단기(deal breaker)가 될 것입니다. 예를 들어, 많은 마이크로 서비스 응용 프로그램은 대기 시간을 향상시키기 위해 인 - 프로세스 캐시 상태를 어느 정도 사용합니다. 마찬가지로 연결 풀 (데이터베이스 또는 다른 서비스에 대한 지속적인 HTTP 연결을 통해)은 또 다른 형태의 상태입니다.

고 처리량 응용 프로그램에 대한 한 가지 해결 방법은 기능 인스턴스를 오래 유지하고 정기적인 in-process 캐싱 접근 방식을 사용하도록하는 것입니다. 캐시가 모든 요청에 ​​대해 warm해지지 않으므로 100 %의 시간 동안 작동하지 않지만, 이는 자동 크기 조정을 사용하여 기존에 배포 된 앱에 대해 이미 존재하는 것과 동일한 우려 사항입니다.

더 나은 솔루션은 매우 낮은 네트워크 오버 헤드로 Redis 데이터베이스를 쿼리하는 것과 같은 out-of-process 데이터에 대한 대기 시간이 매우 적은 액세스입니다. Amazon이 Elasticache 제품에 이미 호스팅 된 Redis 솔루션을 제공하고 있으며 게재 위치 그룹(placement group)을 사용하여 EC2 (서버) 인스턴스의 상대적 위치를 이미 이미 지정할 수 있다는 점을 감안할 때 너무 많은 일은 아닙니다.

우리가 보게 될 것이라고 생각하는 것은 프로세스 상태가없는 제약을 고려하기 위해 포용 된 다양한 종류의 응용 프로그램 아키텍처입니다. 예를 들어 대기 시간이 짧은 응용 프로그램의 경우 초기 요청을 처리하는 일반 서버를 볼 수 있으며 로컬 및 외부 상태에서 해당 요청을 처리하는 데 필요한 모든 컨텍스트를 수집 한 다음 완전히 컨텍스트 화 된 요청을 자체적으로 수행하는 FaaS 기능 팜에 전달할 수 있습니다 외부에서 데이터를 검색 할 필요가 없습니다.

#### Platform Improvements

현재 Serverless FaaS의 단점은 플랫폼 구현 방식에 있습니다. 실행 기간, 시작 대기 시간, 실행 제한의 비 분리는 3 가지 명백한 것들입니다. 이것들은 새로운 솔루션으로 수정되거나 가능한 추가 비용으로 해결 방법이 제공 될 가능성이 있습니다. 예를 들어, 고객이 이 가용성을 위해 비용을 지불하고 낮은 지연 시간에 항상 사용할 수있는 FaaS 기능의 2 가지 인스턴스를 고객이 요청할 수있게함으로써 Startup Latency가 완화 될 수 있다고 상상할 수 있습니다.

우리는 물론 현재의 결함을 수정하는 것 이상의 플랫폼 개선을 보게 될 것입니다.

#### Education

Serverless의 많은 벤더에 고유 한 단점은 교육을 통해 완화 될 것입니다. 이러한 플랫폼을 사용하는 모든 사람들은 하나 이상의 응용 프로그램 공급 업체가 호스팅하는 생태계를 너무 많이 가지고 있다는 것을 의미하는 것에 대해 적극적으로 생각해야합니다. 고려해야 할 질문은 '다른 공급 업체가 제공하지 않는 병렬 솔루션을 고려해야합니까? 애플리케이션이 부분적으로 중단 된 경우 어떻게 정상적으로 성능이 저하됩니까?'

교육을위한 또 다른 영역은 기술 운영입니다. 요즘 많은 팀이 이전보다 'Sys Admins'가 적고 Serverless는 이러한 변화를 가속화 할 것입니다. 그러나 Sys Admins는 유닉스 박스 및 chef 스크립트를 구성하는 것 이상을 수행합니다. 이들은 또한 종종 지원, 네트워킹, 보안 등의 최전선에있는 사람들입니다.

진정한 DevOps 문화는 서버가없는 세계에서 더욱 중요 해집니다. 다른 비 Sys Admin 활동은 아직 끝내야 할 필요가 있으며, 때로는 책임이있는 개발자가되기도합니다. 이러한 활동은 많은 개발자와 기술 담당자에게 자연스럽게 제공되지 않을 수 있으므로 교육 및 운영 담당자와의 긴밀한 협력이 가장 중요합니다.

#### Increased transparency / clearer expectations from Vendors

마지막으로 완화 대상 공급 업체는 호스팅 기능에 대한 더 많은 지원을 위해 계속해서 플랫폼에 대한 기대감을 더욱 분명히해야합니다. 마이그레이션 플랫폼은 어렵지만 불가능하지 않으며 신뢰할 수없는 공급 업체는 고객이 다른 곳에서 비즈니스를 수행하는 것을 보게됩니다.

### The emergence of patterns

기본 플랫폼의 장점과는 별개로, 서버리스 아키텍처를 언제 어떻게 사용해야하는지에 대한 이해는 아직 초기 단계에 있습니다. 지금 당장 팀은 Serverless 플랫폼에서 모든 아이디어를 던지고 무엇이 달라 지는지 봅니다. 개척자에게 감사드립니다!

그러나 어느 시점에 곧 권장 사례의 패턴이 나타나기 시작할 것입니다.

이러한 패턴 중 일부는 응용 프로그램 아키텍처에 포함됩니다. 예를 들어 FaaS 함수가 다루기 힘들어지기 전에 얼마나 커질 수 있습니까? 우리는 FaaS 기능 그룹을 원자 적으로 배치 할 수 있다고 가정하면 그런 그룹화를 만드는 좋은 방법은 무엇입니까? 우리는 현재 로직을 마이크로 서비스로 집약하는 방법과 밀접하게 연관되어 있습니까? 아니면 아키텍처의 차이가 우리를 다른 방향으로 밀어 붙입니까?

FaaS와 기존의 '항상 켜져있는'지속적인 서버 구성 요소간에 하이브리드 아키텍처를 만드는 좋은 방법은 무엇입니까? BaaS를 기존 생태계에 도입하는 좋은 방법은 무엇입니까? 그리고 그 반대의 경우, BaaS 시스템이 완전히 사용자 정의 된 서버 측 코드를 수용하거나 사용하기 시작해야한다는 경고 신호는 무엇입니까?

더 많은 사용 패턴이 나타납니다. FaaS의 표준 예제 중 하나는 미디어 변환입니다.: "대형 미디어 파일이 S3 버킷에 저장 될 때마다 자동으로 프로세스를 실행하여 다른 버킷에 더 작은 버전을 만듭니다." 그러나 우리의 특별한 사용 사례가 Serverless 방식에 적합한 지 알아보기 위해 더 많은 사용 패턴을 카탈로그화 해야합니다.

애플리케이션 아키텍처 이외에도 툴링이 개선되면 권장 운영 패턴을 살펴보기 시작합니다. FaaS, BaaS 및 기존 서버의 하이브리드 아키텍처에 대한 로깅을 논리적으로 어떻게 집계합니까? 발견을위한 좋은 아이디어는 무엇입니까? API 게이트웨이에서 FaaS 웹 애플리케이션을 사용하기 위해 카나리아를 어떻게 출시합니까? FaaS 기능을 가장 효과적으로 디버깅하려면 어떻게해야합니까?

### Beyond ‘FaaSification’

지금까지 본 FaaS의 대부분의 사용법은 기존 코드 / 설계 아이디어를 사용하고 그들을 'FaaSifying'하는 것입니다. - 그것들을 일련의 무상태 function으로 변환합니다. 이것은 강력합니다, 그러나 더 많은 추상화와 어쩌면 FaaS를 기본 구현으로 사용하는 언어를 더 볼 수 있기를 기대합니다. 그러면, 개발자는 FaaS의 이점을 개별 기능 세트로 실제로 적용하지 않고도 FaaS의 이점을 활용할 수 있습니다.(This is powerful, but I also expect that we’ll start to see more abstractions and possibly languages using FaaS as an underlying implementation that give developers the benefits of FaaS without actually thinking about their application as a set of discrete functions.)

예를 들어 Google이 데이터 흐름 제품에 FaaS 구현을 사용하는지 여부는 모르지만 비슷한 제품을 만든 제품이나 오픈 소스 프로젝트를 만든 사람을 상상해 볼 수 있으며 구현으로 FaaS를 사용했습니다. 여기 비교는 Apache Spark와 비슷합니다. Spark은 Amazon EMR / Hadoop을 기본 플랫폼으로 사용할 수있는 매우 높은 수준의 추상화를 제공하는 대규모 데이터 처리 도구입니다.

### Testing

'단점'섹션에서 설명한 것처럼 Serverless 시스템의 통합 및 수용 테스트 영역에서해야 할 일이 많이 있습니다. 우리는 공급 업체가 클라우드 기반일 가능성이 있는 제안을 내놓을 것입니다. 그런 다음 개발 컴퓨터에서 모든 것을 테스트 할 수 있기를 원하는 나와 같은 오래된 조직의 대안을 보게 될 것으로 생각됩니다. 온라인 및 오프라인 테스트 모두에 적합한 솔루션을 찾는 것으로 판단되지만 몇 년이 걸릴 수 있습니다.

### Portable implementations

현재 널리 사용되는 모든 Serverless 구현은 클라우드의 타사 공급 업체 시스템에 배포한다고 가정합니다. 이는 우리가 유지 보수해야 할 Serverless-less 기술의 이점 중 하나입니다. 그러나 회사가 이러한 기술을 사용하여 자체 시스템에서 실행하고 내부 서비스로 제공하려는 경우 여기에 문제가 있습니다.

마찬가지로 모든 구현에는 전개 포인트, 구성, 기능 인터페이스 등의 고유 한 통합 포인트가 있습니다. 이는 앞서 언급 한 공급 업체에 락-인 된다는 단점을 가져옵니다.

이러한 우려를 완화하기 위해 만들어진 다양한 휴대용 구현물을 기대합니다. 나는 2 번째 것을 먼저 토론 할 것입니다.

#### Abstractions over Vendor implementations

우리는 이미 Serverless Framework 및 Lambada Framework와 같은 오픈 소스 프로젝트에서 이와 같은 것을보기 시작했습니다. 여기에서 우리가 개발 한 서버리스 앱을 어디서 어떻게 전개 할 것인가를 중립적으로 개발하고 코드화하고 운영 할 수 있다는 것이 좋은 아이디어입니다. 각 플랫폼의 운영 기능에 따라 AWS API Gateway + Lambda 및 Auth0 웹 태스크 간을 쉽게 전환 할 수 있다면 좋을 것입니다.

우리는 제품의 범용화가 더 많이 나타날 때까지 그러한 추상화가 완료 될 것이라고 기대하지 않지만, 좋은 점은 이 아이디어가 점진적으로 구현 될 수 있다는 것입니다. 우리는 앞에서 언급 한 AWS의 Flourish 프로젝트일지도 모르는 교차 벤더 (cross-vendor) 배포 도구로 시작하여 거기에서 더 많은 기능을 구축 할 수 있습니다.

이러한 까다로운 부분 중 하나는 표준화에 대한 아이디어가 없더라도 추상화 된 FaaS 코딩 인터페이스를 모델링하는 것이지만 우선 비 독점적 인 FaaS 트리거를 사용하여 진행할 수 있다고 기대할 수 있습니다. 예를 들어, AWS S3 또는 Kinesis Lambdas의 추상화와 같은 것을보기 전에 웹 요청 및 예약 된 ( 'cron') Lambda의 추상화를 볼 수 있습니다.

#### Deployable implementations

우리가 타사 공급자를 사용하지 않고 Serverless 기술을 사용하는 것을 제안하는 것은 이상하게 들릴지 모르지만 이러한 생각을 고려하십시오.

- 아마도 우리는 대규모의 기술 조직 일 것이고 우리는 모든 모바일 애플리케이션 개발 팀에게 Firebase와 같은 데이터베이스 경험을 제공하기를 원합니다. 그러나 기존 데이터베이스 아키텍처를 백엔드로 사용하려고합니다.
- 우리는 일부 프로젝트에 FaaS 스타일 아키텍처를 사용하고 싶지만 컴플라이언스 / 법률 / 기타 등을 이유로 '온 프레미스 (on premise)'애플리케이션을 실행해야합니다.

이 중 하나의 경우에도 벤더 호스팅에서 오는 것없이 Serverless 방식을 사용하면 많은 이점이 있습니다. 여기에 선례가 있습니다 - PaaS (Platform-as-a-Service)를 고려하십시오. 최초의 인기있는 PaaS는 모두 클라우드 기반 (예 : Heroku)이지만, 사람들은 자체 시스템에서 PaaS 환경 (즉, Cloud Foundry)의 '개인 PaaS'(PaaS)를 실행함으로써 얻을 수있는 이점을 상당히 빨리 보았습니다.

개인 PaaS 구현과 마찬가지로 BaaS 및 FaaS 개념의 오픈 소스 및 상업용 구현이 널리 보급 된 것을 볼 수 있습니다. Galactic Fog는 초기 FaaS 구현을 포함하여 이 분야의 초기 오픈 소스 프로젝트의 한 예입니다. 위에서 언급한 벤더 추상화와 마찬가지로 점진적 접근 방식을 볼 수 있습니다. 예를 들어 Kong 프로젝트는 오픈 소스 API 게이트웨이 구현입니다. 글을 쓰는 시점에서 AWS Lambda와 통합되지는 않았지만 (이것이 효과가 있었음에도 불구하고) 그렇게했다면 흥미로운 혼합 접근 방식이 될 것입니다.

#### Community

저는 Serverless 커뮤니티의 엄청난 성장을 기대합니다. 지금은 한 컨퍼런스가 있었고 전 세계에 몇 차례의 만남이 있습니다. Docker 및 Spring과 관련된 많은 커뮤니티 (많은 컨퍼런스, 많은 커뮤니티 및 온라인 포럼)가 ​​여러분이 추적 할 수있는 것보다 더 많이 볼 수 있기를 기대합니다.

## 결론

Serverless는, 혼란스러운 이름 임에도 불구하고, 우리의 애플리케이션의 일부로 자체 서버 측 시스템을 실행하는 데 평소보다 더 작은 범위로 의존하는 아키텍처 스타일입니다. 

우리는 두 가지 기술을 통해이 작업을 수행합니다. - 타사 원격 응용 프로그램 서비스를 응용 프로그램의 프런트 엔드에 직접 통합하는 서비스 BaaS, 그리고 서버 측 코드를 장기 실행 구성 요소에서 임시 함수 인스턴스로 이동시키는 서비스인 FaaS

서버가 없으면 모든 문제에 대해 올바른 접근법이 될 수 없으므로 모든 기존 아키텍처를 대체 할 것이라고 말하는 사람은 조심하십시오. 이제는 특히 FaaS 영역에서 Serverless 시스템으로 뛰어 들게되면 더욱 신중해야합니다. 약탈 될 재물 (확장 및 저장 노력)이 있지만, 다음 코너 주변에는 드래곤 (디버깅, 모니터링)이 숨어 있습니다.

그러나 운영 및 개발 비용 절감, 운영 관리의 용이성 및 환경 영향 감소와 같은 Serverless Architecture에 대한 중요한 긍정적 인 측면이 있기 때문에 이러한 이점을 신속하게 해결해서는 안됩니다. 내게있어 가장 중요한 이점은 새로운 애플리케이션 구성 요소를 만드는 피드백 루프가 줄어든다는 것입니다. 나는 초기 사용자 의견을 얻기 위해 가능한 한 빨리 최종 사용자 앞에서 기술을 얻는 데 많은 가치가 있다고 생각하기 때문에 '린 (lean)'접근법을 매우 좋아합니다. Serverless와 함께 이 철학에 적합합니다.

serverless 시스템은 여전히 ​​초기 단계에 있습니다. 앞으로 몇 년 동안이 분야에서 많은 진보가있을 것이며, 그들이 우리의 건축 툴킷에 어떻게 들어 맞는가를 보는 것은 매력적 일 것입니다.

# Origin of ‘Serverless’

'서버리스 (Serverless)'라는 용어는 이러한 애플리케이션에서 서버 하드웨어와 서버 프로세스가 어딘가에서 실행되기 때문에 혼란 스럽지만 일반적인 접근 방식과의 차이점은 '서버가 필요없는'애플리케이션을 구축하고 지원하는 조직이 하드웨어 나 프로세스를 돌보지 않는다는 것입니다. 그들은 벤더에게 이것을 아웃소싱하고 있습니다.

이 용어의 첫 번째 용도는 Ken Fromm의이 기사를 포함하여 2012 년경에 등장한 것으로 보입니다. Badri Janakiraman은 회사의 자체 서버보다는 서비스로 호스팅되는 지속적인 통합 및 소스 제어 시스템과 관련하여 이 시간 전후로 용어 사용법을 들었다고 말합니다. 그러나 이러한 사용은 제품에 통합되기보다는 개발 인프라에 관한 것이 었습니다.

AWS Lambda가 2014 년에 출시되고 2015 년 7 월 Amazon의 API Gateway가 출시 된 후 2015 년에 더 자주 용어가 사용되기 시작합니다. Ant Stanley가 API Gateway 발표 이후 Serverless에 대해 쓴 사례가 있습니다. 2015 년 10 월, Amazon의 re : Inventing conference에서 "AWS Lambda를 사용하는 Serverless Company"라는 제목으로 PlayOn Sport!에서 언급했습니다. 2015 년 말, Javascript Amazon Web Services (JAWS)의 오픈 소스 프로젝트는 Serverless Framework로 바뀌어 추세를 이어갔습니다.

오늘(2016 중반)과 앞으로의 빠른 진행은 최근의 서버리스 컨퍼런스 (Serverless Conference)와 다양한 서버리스 벤더 (Serverless vendors)가 제품 설명에서 작업 설명에 이르는 용어를 채택한 사례를보고 있습니다. Serverless는 용어로서, 좋든 나쁘 든간에 여기 있습니다.

## 참고
- https://martinfowler.com/articles/serverless.html
- https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4_%EC%BB%B4%ED%93%A8%ED%8C%85
- https://martinfowler.com/articles/serverless.html
