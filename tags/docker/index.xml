<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on DIGITAL LABS</title>
    <link>http://tech.cloudz-labs.io/tags/docker/</link>
    <description>Recent content in docker on DIGITAL LABS</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 20 May 2018 18:13:30 +0900</lastBuildDate>
    
	<atom:link href="http://tech.cloudz-labs.io/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Docker-User Defined Network 활용(3/3)] Docker User Defined Bridge Network with Spring Cloud</title>
      <link>http://tech.cloudz-labs.io/posts/docker-user-defined-network/docker-user-defined-network-with-spring-cloud/</link>
      <pubDate>Sun, 20 May 2018 18:13:30 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker-user-defined-network/docker-user-defined-network-with-spring-cloud/</guid>
      <description>지난 포스팅에서 Docker의 네트워크 기능과 연관된 factors를 경우의 수에 따라 검증을 했습니다.
Docker toolbox를 사용하는 환경(win7)에서 테스트 결과, 아래의 경우에 서비스 간 호출이 성공했습니다.
 컨테이너의 Port를 노출하고 {docker-machine ip}:{외부 노출 Port}으로 접속한 경우 컨테이너를 user defined network에 연결하고 {컨테이너 명}:{컨테이너 내부 port}로 접근한 경우 컨테이너를 user defined network에 연결하고 {user defined network ip}:{컨테이너 내부 port}로 접근한 경우  이 중 2번. 컨테이너를 user defined network에 연결하고 {컨테이너 명}:{컨테이너 내부 port}로 접근하는 방법으로 Docker에서 최소 단위의 MSA가 적용된 system을 구성해보겠습니다.</description>
    </item>
    
    <item>
      <title>Docker 시작하기</title>
      <link>http://tech.cloudz-labs.io/posts/docker/docker-start/</link>
      <pubDate>Fri, 11 May 2018 17:43:17 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/docker-start/</guid>
      <description>리눅스의 컨테이너 기술은 굉장히 오래전부터 있던 기술입니다. 그런데 왜 최근에 화두로 떠오르고 있는걸까요? 저는 컨테이너 기술 활성화에 크게 기여한 것이 바로 Docker라고 생각합니다. Docker는 Docker Store(구 Docker Hub)라는 퍼블릭한 레지스트리를 통해 여러 기업들에서 참여하여 이미지를 제공해주고 있지요. 오픈소스 솔루션 중에는 없는 이미지를 찾는게 더 어려운 것 같습니다. 이처럼 Docker 생태계가 잘 되어 있는데 그 생태계를 사용자들로 하여금 굉장히 쉽게 활용할 수 있도록 편의성을 제공해주고 있기 때문에 사용자들은 원하는 솔루션에 대한 이미지를 받아서 컨테이너로 띄우기만 하면 끝입니다.</description>
    </item>
    
    <item>
      <title>Digital Transformation Journey</title>
      <link>http://tech.cloudz-labs.io/posts/digital-transformation-journey/</link>
      <pubDate>Tue, 03 Apr 2018 20:59:36 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/digital-transformation-journey/</guid>
      <description>Software is &amp;ldquo;still&amp;rdquo; eating the world  &amp;ldquo;소프트웨어가 세상을 먹어치우고 있다&amp;hellip;여전히!&amp;rdquo;
 &amp;ldquo;Software is eating the world&amp;rdquo; 는 Marc Andreessen이 아주 오래전에 Wall Street Journal에 올렸던 기고입니다. 그 이후 세상은 호텔을 하나도 소유하지 않은 에어비엔비가 숙박업을, 영화관을 하나도 소유하지 않은 넷플릭스가 미디어 산업을, 오프라인 상점을 하나도 소유하지 않았던(지금은 있지만) 아마존이 리테일 산업을 장악하는 세상으로 바뀌어 버렸습니다.
중요한 것은 &amp;ldquo;아직도&amp;rdquo; 먹어치우고 있다는 것입니다.
사실 몇 년 전만 해도 인터넷 서비스, 미디어, 통신, 리테일 외의 전통 산업에서 Digital Disruption은 올 듯 올 듯 하면서 동인이 잘 생기지 않았습니다.</description>
    </item>
    
    <item>
      <title>[Docker-User Defined Network 활용(2/3)] Docker User Defined Bridge Network 테스트</title>
      <link>http://tech.cloudz-labs.io/posts/docker-user-defined-network/docker-user-defined-network-test/</link>
      <pubDate>Wed, 21 Mar 2018 11:16:00 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker-user-defined-network/docker-user-defined-network-test/</guid>
      <description>지난 포스팅에서 docker user defined network의 간단한 설명과 동작을 확인했습니다.
이번에는 docker user defined network를 활용한 컨테이너 간 통신에 연관된 factors를 확인하고 경우의 수에 따라 테스트를 진행하겠습니다.
Docker Network 기능 Service Discovery Docker는 각 Network 내 컨테이너의 ip주소, 컨테이너 명, Hostname 등을 관리합니다. 각 네트워크는 Subnet mask와 Gateway를 가집니다. 기본적으로 컨테이너의 ip주소는 Network에서 관리하는 Pool 중 할당이 됩니다. 할당하고 싶은 ip주소, Hostname이나 network 정보가 있으면 option을 적용해 지정 가능합니다. 각 Network 별 Host정보를 관리하는 기능을 사용해서 컨테이너 명으로 컨테이너 간 통신을 하는 Service Discovery 기능을 수행할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[Docker-User Defined Network 활용(1/3)] Docker User Defined Network 란?</title>
      <link>http://tech.cloudz-labs.io/posts/docker-user-defined-network/what-is-docker-user-defined-network/</link>
      <pubDate>Tue, 20 Mar 2018 18:12:19 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker-user-defined-network/what-is-docker-user-defined-network/</guid>
      <description>Docker는 몇가지 네트워크 드라이버를 기본 제공하여 강력한 네트워크 기능을 활용할 수 있게 합니다.
 bridge: 기본 네트워크 드라이버. docker0이라는 이름의 bridge 네트워크를 생성됩니다. 설정없이 컨테이너를 생성하게되면 docker0 bridge에 컨테이너를 binding 해서 네트워크 기능을 수행합니다. host: 컨테이너 네트워크가 독립/격리되지 않고, Host의 네트워크를 직접적으로 사용합니다. overlay: 서로 다른 Docker Host에서 실행되는 컨테이너 간 통신이 필요하거나, Docker Swarm 상에서 여러 컨테이너를 동시에 운영할 때 유용합니다. Macvlan: Mac주소를 컨테이너에 할당합니다. Docker 데몬은 트래픽을 컨테이너의 MAC 주소로 라우팅합니다.</description>
    </item>
    
    <item>
      <title>CF에 Docker Image 배포</title>
      <link>http://tech.cloudz-labs.io/posts/using_docker_in_cloudfoundry/</link>
      <pubDate>Mon, 12 Mar 2018 13:23:13 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/using_docker_in_cloudfoundry/</guid>
      <description>Cloud에서 애플리케이션은 Cloud Fondry(CF), Docker 등 다양한 환경에 배포할 수 있습니다. CF는 웹 애플리케이션 개발에 특화되어 있어 Docker에 비해 웹 애플리케이션 개발에 필요한 다양한 기능을 제공하고 있습니다. 반면에 Docker는 다양한 형태의 애플리케이션 개발이 가능하며 자유도가 높은 장점을 갖고 있습니다. 이 둘의 장점을 모두 사용하기 위해 Docker Image를 CF에 배포하는 리서치를 진행하여 이를 공유합니다.
사용법 CF 설정 CF에 Docker image를 배포하기 위해서는 diego_docker플래그가 설정되어야 합니다. 아래 코드로 설정할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(8/8)] Docker의 Network</title>
      <link>http://tech.cloudz-labs.io/posts/docker/docker-network/</link>
      <pubDate>Fri, 09 Mar 2018 08:29:07 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/docker-network/</guid>
      <description>Docker Swarm은 두 가지 종류의 Traffic을 생성합니다.
 제어 및 관리 영역 Traffic: Docker Swarm에 대한 참가 및 탈퇴 요청과 같은 Docker Swarm의 관리 Message가 포함됩니다. 해당 Traffic은 항상 암호화됩니다. Application Data 영역 Traffic: Container 및 외부 Client와의 Traffic이 포함됩니다.  이 중에서 해당 Post에서는, Application Data 영역의 Traffic에 대해서 확인해보고자 합니다.
Docker의 Networking에 대한 자세한 내용은 Docker Networking Reference Architecture문서를 참고하시기 바랍니다.
 Docker의 Network 먼저, Docker는 Overlay, Ingress, docker\_gwbridge의 세 가지 Network이 존재합니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(7/8)] Docker Swarm의 구조와 Service 배포하기</title>
      <link>http://tech.cloudz-labs.io/posts/docker/swarm-architecture/</link>
      <pubDate>Fri, 09 Mar 2018 08:27:58 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/swarm-architecture/</guid>
      <description>이제는 구성된 Docker Swarm에 Application을 배포해보겠습니다. Docker Swarm에 Application Image를 배포하기 위해선, Service를 생성해야 합니다. Service는 큰 Application Context 내의 Microservice들의 Image를 의미하며, 예로 HTTP Server, Database 또는 분산 환경에서 실행하고자 하는 다양한 유형의 Runtime Program들이 여기에 속한다고 할 수 있습니다. Service를 생성하고자 할 때, 사용할 Container Image와 Container 내에서 실행할 명령을 지정합니다. 또한, 다음과 같은 Option들을 정의하여 사용합니다.
 Docker Swarm 외부에서 접속할 수 있는 Port Docker Swarm 내부의 다른 Service와 통신하기 위한 Overlay Network CPU 및 Memory 사용에 대한 정책 Rolling Update 정책 Image의 Replica 개수  Service Service가 독립형 Container들을 직접 실행하는 것에 비해 갖는 주요 장점 중 하나는, 수동으로 Service를 다시 시작할 필요없이 연결된 Network 및 Volume 등의 구성을 수정할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(6/8)] Docker의 Container Ochestartion: Swarm</title>
      <link>http://tech.cloudz-labs.io/posts/docker/swarm/</link>
      <pubDate>Fri, 09 Mar 2018 08:27:01 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/swarm/</guid>
      <description>지금까지는 단일 Docker Machine에서 Container를 실행시켜 서비스를 제공했습니다. 그렇다면, 현 상태로 실제 서비스를 운영할 수 있을까요? 한참 부족합니다! 장애없이 원활한 서비스를 제공하기 위해서는, 내결함성, 고가용성 등등 많은 사항들을 고려하여야 합니다. 결국은 단일 Machine으로는 사용할 수 없고 Cluster 형태로 구성되어야하며, 그 위에서 서비스들은 여러개의 Instance로 부하가 분산되어야 하며, 장애가 발생하더라도 스스로 복구 할 수 있는 구조로 실행되어야 합니다. 마지막으로 이것들이 자동화되어 있어야합니다. 수 십개에서 수 백개로 나뉘어진 Service들을 사람이 직접 관리할 수 없기 때문입니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(5/8)] Volume을 활용한 Data 관리</title>
      <link>http://tech.cloudz-labs.io/posts/docker/volume/</link>
      <pubDate>Fri, 09 Mar 2018 08:25:25 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/volume/</guid>
      <description>우리는 Container의 Writable Layer에 Data를 저장할 수 있다는 것을 알고 있습니다. 하지만, 여기에는 몇 가지 문제점이 존재합니다.
 Container가 삭제되면 Data도 같이 삭제됩니다. 또한, 다른 프로세스에서 Container에 저장된 Data를 사용하기 어렵습니다. Container의 Writable Layer에는 Container가 실행 중인 Host Machine과 밀접하게 연결됩니다. 따라서, Data를 다른 곳으로 쉽게 옮길 수 없습니다. Container의 Writable Layer에 Data를 저장하기 위해서는 File System을 관리하는 Storage Driver가 필요합니다. Storage Driver는 Linux 커널을 사용하여 공용 File System을 제공합니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(4/8)] docker build &amp; push</title>
      <link>http://tech.cloudz-labs.io/posts/docker/docker-build-push/</link>
      <pubDate>Fri, 09 Mar 2018 08:23:38 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/docker-build-push/</guid>
      <description>Docker 환경에 Service 및 Application을 구동시키 위한 전체적인 과정은 다음과 같습니다.
graph BT; A[Dockerfile] --|build| B[Images] B --|push| C[Docker Registry] C --|pull| B subgraph Local Docker Instance B --|Run| D[Container] end  지금까지는, Docker Registry(Docker Hub)에 배포되어 있는 있는 Image를 이용해 Container를 구동시켰습니다. 이제부터는 위에서 정리한 과정대로, Dockerfile로 Image를 생성하고 다른 Machine에서 배포된 Image로 Container를 실행시켜 보겠습니다.
본 예제는 About storage drivers에 있는 예제를 참고하여 진행했습니다.
 신규 Image 생성에서 배포까지 Dockerfile 작성 image-build-test 폴더를 생성한 뒤, 다음의 내용이 포함된 Dockerfile을 생성합니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(3/8)] Container는 뭘까?</title>
      <link>http://tech.cloudz-labs.io/posts/docker/what-is-container/</link>
      <pubDate>Fri, 09 Mar 2018 08:22:39 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/what-is-container/</guid>
      <description>Docker는 Application의 배포와 운영을 쉽게 도와주는 &amp;lsquo;Containers as a Service(CaaS) Platform이며, Client-Server Model로 동작하고 있습니다. 여기서 Container란, 운영체제의 커널이 하나의 인스턴스가 아닌, 여러 개의 격리된 인스턴스들을 갖출 수 있도록 하는 서버 가상화 방식입니다. 이러한 인스턴스들은 이를 소유하고 있는 Host Machine과 사용자의 관점에서 바라보면, 실제 서버인 것처럼 보입니다.
가상화(Virtualization) Container는 가상화 방식의 한 종류입니다. 하지만, 흔히 우리가 알고있는 가상화(Virtualization)는 VMWare Workstation과 같은 소프트웨어를 이용해, Linux나 MacOS위에 Windows를 올려서 사용하는 그런 것을 떠올릴 것입니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(2/8)] Docker&#39;s Skeleton</title>
      <link>http://tech.cloudz-labs.io/posts/docker/docker-architecture/</link>
      <pubDate>Thu, 08 Mar 2018 23:23:28 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/docker-architecture/</guid>
      <description>Docker는 Container를 구동시킬 수 있는 환경만 구성되어 있다면, Application들을 한 번의 Build로 어디서든 구동시킬 수 있습니다. 하지만 1차원적으로만 살펴보면, Java Application이 JVM 위에서 실행되는 모습과 크게 다르지 않아 보입니다. Java Application도 JVM만 설치되어 있다면, 어디에서든 실행되죠. 마찬가지로, Python Application도 동일합니다. 그렇다면, 이 모든 것들이 결국은 똑같이 생겼고, 단지 실행되는 주체(Container, JAR, py)만 다른 것일까요?
Client-Server Model Docker는 서비스의 요청자(Docker Client)와 제공자(Docker Server)간의 작업이 분리되어 동작하는 Client-Server Model로 되어있으며, Docker Client는 REST API를 사용하여 Docker Server를 제어합니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(1/8)] Hello Docker!</title>
      <link>http://tech.cloudz-labs.io/posts/docker/hello-docker/</link>
      <pubDate>Thu, 08 Mar 2018 18:47:30 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/hello-docker/</guid>
      <description>Docker란 리눅스의 응용프로그램들을 소프트웨어 Container 안에 배치시키는 일을 자동화하는 오픈 소스 프로젝트로서, Docker 공식 문서에 따르면 Containers as a Service(CaaS) Platform으로 정의하고 있습니다.
Docker는 홈페이지에 Docker의 기능을 아래와 같이 명시 하고 있습니다.
 Docker Container는 일종의 소프트웨어 실행에 필요한 모든 것들을 포함하는 완전한 파일 시스템 안에 감싼다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는 무엇이든 전부 아우른다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.</description>
    </item>
    
    <item>
      <title>Docker in docker</title>
      <link>http://tech.cloudz-labs.io/posts/docker-in-docker/</link>
      <pubDate>Wed, 28 Feb 2018 10:59:06 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker-in-docker/</guid>
      <description>지난 한주 동안 애플리케이션을 Kubernetes 배포하는 CI/CD 파이프라인 구성했습니다. K8S CI/CD 파이프라인 구성은 차후에 포스팅하기로 하고, K8S용 파이프라인 구성에 사용된 Docker in docker 기술을 소개하겠습니다.
DinD(Docker In Docker)기술은 컨테이너 내부에 Docker를 사용하는 기술을 말하며 일반적으로 K8S CI/CD 구성, Docker 엔진 개발 등에 사용됩니다.
DinD 원리 DinD 원리를 이해하기 위해서는 Docker의 명령어 실행 구조를 이해해야 합니다.
Docker를 설치/실행하면 Docker daemon과 Docker CLI가 설치/실행됩니다. 콘솔 화면에서 Docker 명령어를 입력할 경우 Docker CLI가 명령어를 받아서 Socket을 통해 Docker daemon에 전달합니다.</description>
    </item>
    
    <item>
      <title>K8S App deploy script</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes_deploy_script/</link>
      <pubDate>Fri, 23 Feb 2018 16:42:27 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes_deploy_script/</guid>
      <description>최근 Container 기술이 각광을 받고 있습니다. 그래서 저도 Kubernets 교육을 수강하고 있는데, Kubernets에 배포 한번 하기 참 힘드네요. Project build, Docker image build, Docker push, K8s deploy 총 4개의 과정을 거쳐야 애플리케이션 배포가 끝이 납니다. 도저히 이 과정을 참을 수 없어서 배포 스크립트를 만들었습니다. 사용방법은 아래 설명하였으니, 잘 활용하시기 바랍니다.
사용법 1. deploy.sh 저장 페이지 하단 deploy.sh 파일을 개발중인 프로젝트 루트에 저장합니다.
2. 설정 deploy.sh 파일의 상단 설정을 입력합니다.</description>
    </item>
    
  </channel>
</rss>