<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spring cloud on DIGITAL LABS</title>
    <link>http://tech.cloudz-labs.io/tags/spring-cloud/</link>
    <description>Recent content in spring cloud on DIGITAL LABS</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 01 Jun 2018 08:06:40 +0900</lastBuildDate>
    
	<atom:link href="http://tech.cloudz-labs.io/tags/spring-cloud/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Service Mesh 란?</title>
      <link>http://tech.cloudz-labs.io/posts/service-mesh/</link>
      <pubDate>Fri, 01 Jun 2018 08:06:40 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/service-mesh/</guid>
      <description>수년간 Enterprise IT환경은 급격하게 변하고 있습니다. 특히 Cloud로 대변되는 시스템 구축 환경의 변화에 따라 이를 잘 활용할 수 있는 다양한 Architecture들이 대두되고 있습니다.
Service Mesh Architecture는 MicroService Architecture와 더불어 최근 활발하게 언급되고 있습니다.
이번 포스팅에서는 Service Mesh Architecture가 &amp;lsquo;무엇&amp;rsquo;인지, &amp;lsquo;왜&amp;rsquo; 활발하게 언급되고 있는지, Service Mesh Architecture &amp;lsquo;구현체&amp;rsquo; 간단 소개와 &amp;lsquo;장단점&amp;rsquo; 등을 알아보겠습니다.
Service Mesh 란? Service Mesh는 모티브와 정의, 구현체의 기능 등 다양한 관점에서 용어를 정의하고 있습니다.
 MicroService Architecture를 적용한 시스템의 내부 통신이 Mesh 네트워크의 형태를 띄는 것에 빗대어 Service Mesh로 명명되었습니다.</description>
    </item>
    
    <item>
      <title>[Docker-User Defined Network 활용(3/3)] Docker User Defined Bridge Network with Spring Cloud</title>
      <link>http://tech.cloudz-labs.io/posts/docker-user-defined-network/docker-user-defined-network-with-spring-cloud/</link>
      <pubDate>Sun, 20 May 2018 18:13:30 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker-user-defined-network/docker-user-defined-network-with-spring-cloud/</guid>
      <description>지난 포스팅에서 Docker의 네트워크 기능과 연관된 factors를 경우의 수에 따라 검증을 했습니다.
Docker toolbox를 사용하는 환경(win7)에서 테스트 결과, 아래의 경우에 서비스 간 호출이 성공했습니다.
 컨테이너의 Port를 노출하고 {docker-machine ip}:{외부 노출 Port}으로 접속한 경우 컨테이너를 user defined network에 연결하고 {컨테이너 명}:{컨테이너 내부 port}로 접근한 경우 컨테이너를 user defined network에 연결하고 {user defined network ip}:{컨테이너 내부 port}로 접근한 경우  이 중 2번. 컨테이너를 user defined network에 연결하고 {컨테이너 명}:{컨테이너 내부 port}로 접근하는 방법으로 Docker에서 최소 단위의 MSA가 적용된 system을 구성해보겠습니다.</description>
    </item>
    
    <item>
      <title>Eureka Server 매핑 정보 삭제 delay 현상 in Bluemix</title>
      <link>http://tech.cloudz-labs.io/posts/discovery-duration-error-in-bluemix/</link>
      <pubDate>Mon, 19 Feb 2018 10:39:44 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/discovery-duration-error-in-bluemix/</guid>
      <description>What ? 예전에 bluemix에 배포한 어플리케이션이 eureka와 연계했을 때 생각과 다르게 동작하는 것을 발견했습니다.
해당 현상은 eureka client 어플리케이션이 종료됐을 때, eureka server에서 해당 어플리케이션 정보가 삭제되는데 생각보다 delay가 생기는 것 입니다. (예상 : 5초 내외, but 수 분이상 dashboard 상에서 조회)
어디서 꼬인 것일까요 ?
Why ?  eureka 설정이 잘못됐을 가능성
eureka server 적용된 설정은 아래와 같습니다.
eureka: instance: instance-id: ${vcap.application.instance_id:${spring.application.name}:${spring.application.instance_id:${server.port}}} hostname: ${vcap.application.uris[0]} prefer-ip-address: false non-secure-port: 80 lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 5 client: region: default fetch-registry: false register-with-eureka: false service-url: defaultZone: http://${eureka.</description>
    </item>
    
    <item>
      <title>로컬에서 Spring Cloud Connector 사용하기</title>
      <link>http://tech.cloudz-labs.io/posts/how-to-use-cf-binding-service-in-local-env/</link>
      <pubDate>Tue, 13 Feb 2018 08:34:45 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/how-to-use-cf-binding-service-in-local-env/</guid>
      <description>What? 로컬 개발 환경에서 Spring Cloud Connector를 사용해서 Application에 binding 된 PaaS 서비스를 사용해 봅시다.
Why? 로컬 개발 환경과 PaaS 환경(dev, stg, prod 등) 을 분리하여 개발환경을 구성하는 경우 몇가지 불편한 점이 있습니다.
그 중 하나가 로컬 개발 환경에서 사용하는 서비스와 PaaS 환경에서 사용하는 서비스가 다른 경우입니다.
예를 들면,
 로컬 환경에서 H2 DB 를 쓰다가 MariaDB로 배포하는 경우 쿼리가 다릅니다.
H2:
DROP TABLE IF EXISTS users CASCADE; CREATE TABLE IF NOT EXISTS users ( id INTEGER, username VARCHAR(100) NOT NULL, age INTEGER NOT NULL, job VARCHAR(100) NOT NULL ); ALTER TABLE users MODIFY id INTEGER NOT NULL AUTO_INCREMENT; MariaDB:</description>
    </item>
    
  </channel>
</rss>