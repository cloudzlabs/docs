<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>k8s on DIGITAL LABS</title>
    <link>http://tech.cloudz-labs.io/tags/k8s/</link>
    <description>Recent content in k8s on DIGITAL LABS</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 11 May 2018 13:55:54 +0900</lastBuildDate>
    
	<atom:link href="http://tech.cloudz-labs.io/tags/k8s/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Kubernetes 활용(7/8)] Secret</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/secret/</link>
      <pubDate>Fri, 11 May 2018 13:55:54 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/secret/</guid>
      <description>지난 챕터의 ConfigMap에 이어서 이번에는 Secret Object를 보도록 하겠습니다.
Secret 이란? Secret은 비밀번호나 OAuth 토큰값 또는 ssh key 등의 민감한 정보를 유지하기 위해 사용됩니다. 이러한 정보를 Docker 이미지나 Pod에 그대로 정의하기 보다 Secret을 활용하면 더욱 안전하고 유동적으로 사용할 수 있습니다.
Secret 적용하기 Secret 생성 명령어를 통해 생성하기 아래와 같이 kubectl create secret 명령어를 통해 Secret을 생성합니다.
Window OS의 경우 아래 yaml 파일로 Secret을 직접 생성하는 방식으로 사용하세요.
$ kubectl create secret generic db-user-pass --from-literal=user=admin --from-literal=password=1f2d1e2e67df secret &amp;#34;db-user-pass&amp;#34; created 아래와 같이 kubectl get 명령어와 kuberctl describe 명령어를 통해 생성된 Secret을 확인합니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(6/8)] ConfigMap</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/configmap/</link>
      <pubDate>Fri, 11 May 2018 13:55:48 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/configmap/</guid>
      <description>이번에는 Kubernetes에서 제공하는 ConfigMap이라는 Object를 보도록 하겠습니다.
ConfigMap 이란? ConfigMap은 컨테이너 이미지에서 사용하는 환경변수와 같은 세부 정보를 분리하고, 그 환경변수에 대한 값을 외부로 노출 시키지 않고 내부에 존재하는 스토리지에 저장해서 사용하는 방법입니다. 혹시 마이크로서비스 아키텍처에서 사용하는 Spring Cloud Config(Config Server)를 사용한 적이 있다면 동일한 역할을 하는 것인지 하는 생각이 들 수 있는데요. Spring Cloud Config 같은 경우에는 설정 파일 자체를 분리하고 파일에 대한 내용이 변경된다면 자동으로 Refresh 해주는 기능을 가지고 있습니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(5/8)] Ingress</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/ingress/</link>
      <pubDate>Thu, 10 May 2018 18:24:03 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/ingress/</guid>
      <description>Kubernetes에서는 애플리케이션을 외부로 노출하기 위해 Service object를 NodePort로 생성합니다. 그러나 노출 형태가 노드의 IP에 특정 포트(30000-32767)로 제공되기 때문에 호출이 까다롭고 사용자가 서비스로 유입되는 경로도 다양해서 관리가 어려워질 수 있는데요. 이 때, 외부 액세스를 관리하고 서비스를 묶어주는 역할을 하는게 바로 Ingress 입니다.
Ingress 란? 위 그림과 같이 Ingress는 외부 액세스를 관리하고 서비스를 묶어주는 역할을 합니다. Ingress를 만들 때 도메인을 지정할 수 있고 사용자는 그 도메인으로 접속을 하게 되며 도메인 하위의 path 설정을 통해 서비스들을 라우팅할 수 있게 됩니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(4/8)] Mysql DB 연동하기</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/backingservice/</link>
      <pubDate>Tue, 08 May 2018 15:23:03 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/backingservice/</guid>
      <description>지난 챕터에서는 사용한 리소스를 기반으로 애플리케이션의 수를 자동으로 조절할 수 있는 HPA 라는 기능을 적용해 보았습니다. 그렇다면 애플리케이션에 Mysql 또는 Redis 등과 같은 서비스를 연동하고 싶을 땐 어떻게 해야할까요? Kubernetes에서는 애플리케이션에서 필요한 서비스를 Docker Image를 사용하여 바로 구성할 수 있습니다. 물론 대부분이 오픈소스 솔루션에 대한 서비스겠지요. Legacy에 있는 서비스들 역시 연동이 가능하긴 하지만, 여기서는 Docker Image 를 통해 Mysql DB를 구성하고 애플리케이션에 연동해보도록 하겠습니다.
샘플 애플리케이션에 대한 자세한 설명은 Spring의 Accessing data with MySQL 문서를 참고하시기 바랍니다.</description>
    </item>
    
  </channel>
</rss>