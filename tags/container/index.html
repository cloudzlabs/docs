<!DOCTYPE html>
<html lang='ko' class='svgfilters csscalc cssgradients preserve3d supports svgclippaths svgasimg no-touchevents cssanimations boxsizing csstransforms csstransforms3d csstransitions svg'>

    <head>

    <meta charset='utf-8'>
<meta name='keywords' content='CLOUDZ LABS, DIGITAL LABS'>
<meta name='author' content='CLOUDZ LABS, DIGITAL LABS'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>
<meta name='description' content=''>

<meta name="google-site-verification" content="vMW654gdULy3JNwnOIbbAqHdH3cQKdKH0ocV8OxP5cM" />

<meta property='og:title' content='태그: container | DIGITAL LABS'>
<meta property='og:description' content=''>
<meta property='og:url' content='http://tech.cloudz-labs.io/tags/container/'>
<meta property='og:site_name' content='DIGITAL LABS'>
<meta property='og:type' content='website'><meta property='og:image' content='/images/default.png'><meta property='og:updated_time' content='2018-10-17T10:14:07&#43;09:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.53-DEV" />


    <title>태그: container | DIGITAL LABS</title>

    <link rel='canonical' href='http://tech.cloudz-labs.io/tags/container/'>

    <link rel="alternate" type="application/rss&#43;xml" href="http://tech.cloudz-labs.io/tags/container/index.xml" title="DIGITAL LABS">

    <link rel='icon' href='/favicon-blank.ico'>


<link rel='apple-touch-icon' href='touch-icon-iphone.png'>
<link rel='apple-touch-icon' sizes='152x152' href='touch-icon-ipad.png'>
<link rel='apple-touch-icon' sizes='180x180' href='touch-icon-iphone-retina.png'>
<link rel='apple-touch-icon' sizes='167x167' href='touch-icon-ipad-retina.png'>


<link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">

<link rel='stylesheet' href='/assets/css/main.f0e8df71.css'>

<link rel='stylesheet' href='/assets/css/bootstrap.css'><link rel='stylesheet' href='/assets/css/common.css'><link rel='stylesheet' href='/assets/css/font-awesome.css'><link rel='stylesheet' href='/assets/css/markdown.css'><link rel='stylesheet' href='/assets/css/mermaid.css'><style type="text/css">
:root #header + #content > #left > #rlblock_left{
    display:none !important;
}:not(pre) > code + span.copy-to-clipboard {
        display: none;
    }</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-115004569-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>


    <body naver_screen_capture_injected="true" class="hasScrollbar">

        
<div class="offcanvas-container" id="mobile-menu">
    <nav class="offcanvas-menu">
        <ul class="menu">
            <li class='has-children'>
                <span>
                    <a href='http://dtlabs.skcc.com/?utm_source=tech_blog&amp;utm_campaign=blog_about_us&amp;utm_content=menulink'>
                        <span>About Us</span>
                    </a>
                </span>
            </li>
            <li class='has-children'>
                <span>
                    <a href='/posts/'>
                        <span>Posts</span>
                    </a>
                </span>
            </li>
            
        </ul>
    </nav>
</div>
<div class="site-backdrop"></div>


<header class="navbar navbar-sticky">

    <div class="site-search" method="get">
    <input data-search-input id="search-by" type="text" name="site_search" placeholder="검색어를 3글자 이상 입력하세요.">
    <div class="search-tools">
        <span class="clear-search">Clear</span>
        <span class="close-search">
            <i class="icon-cross"></i>
        </span>
    </div>
</div>
<div class="site-branding">
    <div class="inner">
        <a class="offcanvas-toggle menu-toggle" href="#mobile-menu" data-toggle="offcanvas"></a>
        <a class="site-logo" href="http://tech.cloudz-labs.io/">Digital Labs Tech</a>
    </div>
</div>
<nav class='site-menu'>
    <ul>
        <li >
            <a href='http://dtlabs.skcc.com/?utm_source=tech_blog&amp;utm_campaign=blog_about_us&amp;utm_content=menulink'>
                <span>About Us</span>
            </a>
        </li>
        <li >
            <a href='/posts/'>
                <span>Posts</span>
            </a>
        </li>
        
    </ul>
</nav>

<div class="toolbar">
    <div class="tools">
        <div class="search">
            <i class="fa fa-search" aria-hidden="true"></i>
        </div>
    </div>
</div>


</header>



        

<div class='offcanvas-wrapper'><section class='visual-title bg-tags'>
    <div class="visual mask"><h3>container</h3></div>
</section>
<section class='container'>
        <article class="post">

            
                <div class="fulid-set-12 card mb-30"><div class="row card-style-1">
    <div class="col-md-7 col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/docker/docker-start/">Docker 시작하기</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/blingeeeee">김빛나</a></h4>

            <p class="post-excerpt">리눅스의 컨테이너 기술은 굉장히 오래전부터 있던 기술입니다. 그런데 왜 최근에 화두로 떠오르고 있는걸까요? 저는 컨테이너 기술 활성화에 크게 기여한 것이 바로 Docker라고 생각합니다. Docker는 Docker Store(구 Docker Hub)라는 퍼블릭한 레지스트리를 통해 여러 기업들에서 참여하여 이미지를 제공해주고 있지요. 오픈소스 솔루션 중에는 없는 이미지를 찾는게 더 어려운 것 같습니다. 이처럼 Docker 생태계가 잘 되어 있는데 그 생태계를 사용자들로 하여금 굉장히 쉽게 활용할 수 있도록 편의성을 제공해주고 있기 때문에 사용자들은 원하는 솔루션에 대한 이미지를 받아서 컨테이너로 띄우기만 하면 끝입니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/docker/docker-start/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/docker" rel="tag">docker</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/caas" rel="tag">caas</a></li></ul>

            

        </div><a href="#" class="col-md-5 col-sm-12 col-xs-12"><img class="img-responsive" src='http://tech.cloudz-labs.io/posts/docker/docker-start/../images/docker-start.png'/>

</a></div>
</div>

            
                <div class="fulid-set-12 card mb-30">
    <div class="row card-style-2">
    <div class="col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/kubernetes/secret/">[Kubernetes 활용(7/8)] Secret</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/blingeeeee">김빛나</a></h4>

            <p class="post-excerpt">지난 챕터의 ConfigMap에 이어서 이번에는 Secret Object를 보도록 하겠습니다. Secret 이란? Secret은 비밀번호나 OAuth 토큰값 또는 ssh key 등의 민감한 정보를 유지하기 위해 사용됩니다. 이러한 정보를 Docker 이미지나 Pod에 그대로 정의하기 보다 Secret을 활용하면 더욱 안전하고 유동적으로 사용할 수 있습니다. Secret 적용하기 Secret 생성 명령어를 통해 생성하기 아래와 같이 kubectl create secret 명령어를 통해 Secret을 생성합니다. Window OS의 경우 아래 yaml 파일로 Secret을 직접 생성하는 방식으로 사용하세요. $ kubectl create secret generic db-user-pass --from-literal=user=admin --from-literal=password=1f2d1e2e67df secret &#34;db-user-pass&#34; created 아래와 같이 kubectl get 명령어와 kuberctl describe 명령어를 통해 생성된 Secret을 확인합니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/kubernetes/secret/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/kubernetes" rel="tag">kubernetes</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/container-orchestration" rel="tag">container orchestration</a></li><li><a href="/tags/k8s" rel="tag">k8s</a></li><li><a href="/tags/secret" rel="tag">secret</a></li></ul>

            

        </div></div>
</div>

            
                <div class="fulid-set-12 card mb-30">
    <div class="row card-style-2">
    <div class="col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/kubernetes/configmap/">[Kubernetes 활용(6/8)] ConfigMap</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/blingeeeee">김빛나</a></h4>

            <p class="post-excerpt">이번에는 Kubernetes에서 제공하는 ConfigMap이라는 Object를 보도록 하겠습니다. ConfigMap 이란? ConfigMap은 컨테이너 이미지에서 사용하는 환경변수와 같은 세부 정보를 분리하고, 그 환경변수에 대한 값을 외부로 노출 시키지 않고 내부에 존재하는 스토리지에 저장해서 사용하는 방법입니다. 혹시 마이크로서비스 아키텍처에서 사용하는 Spring Cloud Config(Config Server)를 사용한 적이 있다면 동일한 역할을 하는 것인지 하는 생각이 들 수 있는데요. Spring Cloud Config 같은 경우에는 설정 파일 자체를 분리하고 파일에 대한 내용이 변경된다면 자동으로 Refresh 해주는 기능을 가지고 있습니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/kubernetes/configmap/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/kubernetes" rel="tag">kubernetes</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/container-orchestration" rel="tag">container orchestration</a></li><li><a href="/tags/k8s" rel="tag">k8s</a></li><li><a href="/tags/configmap" rel="tag">configmap</a></li></ul>

            

        </div></div>
</div>

            
                <div class="fulid-set-12 card mb-30"><div class="row card-style-1">
    <div class="col-md-7 col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/kubernetes/ingress/">[Kubernetes 활용(5/8)] Ingress</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/blingeeeee">김빛나</a></h4>

            <p class="post-excerpt">Kubernetes에서는 애플리케이션을 외부로 노출하기 위해 Service object를 NodePort로 생성합니다. 그러나 노출 형태가 노드의 IP에 특정 포트(30000-32767)로 제공되기 때문에 호출이 까다롭고 사용자가 서비스로 유입되는 경로도 다양해서 관리가 어려워질 수 있는데요. 이 때, 외부 액세스를 관리하고 서비스를 묶어주는 역할을 하는게 바로 Ingress 입니다. Ingress 란? 위 그림과 같이 Ingress는 외부 액세스를 관리하고 서비스를 묶어주는 역할을 합니다. Ingress를 만들 때 도메인을 지정할 수 있고 사용자는 그 도메인으로 접속을 하게 되며 도메인 하위의 path 설정을 통해 서비스들을 라우팅할 수 있게 됩니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/kubernetes/ingress/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/kubernetes" rel="tag">kubernetes</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/container-orchestration" rel="tag">container orchestration</a></li><li><a href="/tags/k8s" rel="tag">k8s</a></li><li><a href="/tags/service" rel="tag">service</a></li><li><a href="/tags/ingress" rel="tag">ingress</a></li><li><a href="/tags/nginx" rel="tag">nginx</a></li></ul>

            

        </div><a href="#" class="col-md-5 col-sm-12 col-xs-12"><img class="img-responsive" src='http://tech.cloudz-labs.io/posts/kubernetes/ingress/../ingress/ingress.png'/>

</a></div>
</div>

            
                <div class="fulid-set-12 card mb-30">
    <div class="row card-style-2">
    <div class="col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/kubernetes/backingservice/">[Kubernetes 활용(4/8)] Mysql DB 연동하기</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/blingeeeee">김빛나</a></h4>

            <p class="post-excerpt">지난 챕터에서는 사용한 리소스를 기반으로 애플리케이션의 수를 자동으로 조절할 수 있는 HPA 라는 기능을 적용해 보았습니다. 그렇다면 애플리케이션에 Mysql 또는 Redis 등과 같은 서비스를 연동하고 싶을 땐 어떻게 해야할까요? Kubernetes에서는 애플리케이션에서 필요한 서비스를 Docker Image를 사용하여 바로 구성할 수 있습니다. 물론 대부분이 오픈소스 솔루션에 대한 서비스겠지요. Legacy에 있는 서비스들 역시 연동이 가능하긴 하지만, 여기서는 Docker Image 를 통해 Mysql DB를 구성하고 애플리케이션에 연동해보도록 하겠습니다. 샘플 애플리케이션에 대한 자세한 설명은 Spring의 Accessing data with MySQL 문서를 참고하시기 바랍니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/kubernetes/backingservice/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/kubernetes" rel="tag">kubernetes</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/container-orchestration" rel="tag">container orchestration</a></li><li><a href="/tags/%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%97%B0%EB%8F%99" rel="tag">서비스 연동</a></li><li><a href="/tags/db-%EC%97%B0%EB%8F%99" rel="tag">db 연동</a></li><li><a href="/tags/service-discovery" rel="tag">service discovery</a></li><li><a href="/tags/k8s" rel="tag">k8s</a></li></ul>

            

        </div></div>
</div>

            
                <div class="fulid-set-12 card mb-30">
    <div class="row card-style-2">
    <div class="col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/docker/docker-build-push/">[Docker 기본(4/8)] docker build &amp; push</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/1000jaeh">정재훈</a></h4>

            <p class="post-excerpt">Docker 환경에 Service 및 Application을 구동시키 위한 전체적인 과정은 다음과 같습니다. graph BT; A[Dockerfile] --|build| B[Images] B --|push| C[Docker Registry] C --|pull| B subgraph Local Docker Instance B --|Run| D[Container] end 지금까지는, Docker Registry(Docker Hub)에 배포되어 있는 있는 Image를 이용해 Container를 구동시켰습니다. 이제부터는 위에서 정리한 과정대로, Dockerfile로 Image를 생성하고 다른 Machine에서 배포된 Image로 Container를 실행시켜 보겠습니다. 본 예제는 About storage drivers에 있는 예제를 참고하여 진행했습니다. 신규 Image 생성에서 배포까지 Dockerfile 작성 image-build-test 폴더를 생성한 뒤, 다음의 내용이 포함된 Dockerfile을 생성합니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/docker/docker-build-push/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/docker" rel="tag">docker</a></li><li><a href="/tags/image" rel="tag">image</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/dockerfile" rel="tag">dockerfile</a></li></ul>

            

        </div></div>
</div>

            
                <div class="fulid-set-12 card mb-30"><div class="row card-style-1">
    <div class="col-md-7 col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/docker/what-is-container/">[Docker 기본(3/8)] Container는 뭘까?</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/1000jaeh">정재훈</a></h4>

            <p class="post-excerpt">Docker는 Application의 배포와 운영을 쉽게 도와주는 ‘Containers as a Service(CaaS) Platform이며, Client-Server Model로 동작하고 있습니다. 여기서 Container란, 운영체제의 커널이 하나의 인스턴스가 아닌, 여러 개의 격리된 인스턴스들을 갖출 수 있도록 하는 서버 가상화 방식입니다. 이러한 인스턴스들은 이를 소유하고 있는 Host Machine과 사용자의 관점에서 바라보면, 실제 서버인 것처럼 보입니다. 가상화(Virtualization) Container는 가상화 방식의 한 종류입니다. 하지만, 흔히 우리가 알고있는 가상화(Virtualization)는 VMWare Workstation과 같은 소프트웨어를 이용해, Linux나 MacOS위에 Windows를 올려서 사용하는 그런 것을 떠올릴 것입니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/docker/what-is-container/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/docker" rel="tag">docker</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/virtualization" rel="tag">virtualization</a></li><li><a href="/tags/layer" rel="tag">layer</a></li></ul>

            

        </div><a href="#" class="col-md-5 col-sm-12 col-xs-12"><img class="img-responsive" src='http://tech.cloudz-labs.io/posts/docker/what-is-container/../images/container.jpg'/>

</a></div>
</div>

            
                <div class="fulid-set-12 card mb-30"><div class="row card-style-1">
    <div class="col-md-7 col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/docker/hello-docker/">[Docker 기본(1/8)] Hello Docker!</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/1000jaeh">정재훈</a></h4>

            <p class="post-excerpt">Docker란 리눅스의 응용프로그램들을 소프트웨어 Container 안에 배치시키는 일을 자동화하는 오픈 소스 프로젝트로서, Docker 공식 문서에 따르면 Containers as a Service(CaaS) Platform으로 정의하고 있습니다. Docker는 홈페이지에 Docker의 기능을 아래와 같이 명시 하고 있습니다. Docker Container는 일종의 소프트웨어 실행에 필요한 모든 것들을 포함하는 완전한 파일 시스템 안에 감싼다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는 무엇이든 전부 아우른다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.
                    </p>

            <p class="btn-link">
                <a href="/posts/docker/hello-docker/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/docker" rel="tag">docker</a></li><li><a href="/tags/caas" rel="tag">caas</a></li><li><a href="/tags/container" rel="tag">container</a></li></ul>

            

        </div><a href="#" class="col-md-5 col-sm-12 col-xs-12"><img class="img-responsive" src='http://tech.cloudz-labs.io/posts/docker/hello-docker/../images/docker-official.svg'/>

</a></div>
</div>

            
                <div class="fulid-set-12 card mb-30">
    <div class="row card-style-2">
    <div class="col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/kubernetes/hpa/">[Kubernetes 활용(3/8)] HPA(오토스케일링)</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/blingeeeee">김빛나</a></h4>

            <p class="post-excerpt">지난 챕터에서는 이미 배포되어 있는 애플리케이션을 무중단으로 업데이트하는 방법에 대해 보았습니다. 이번에는 이어서 애플리케이션을 자동으로 Scale-out 할수 있는 Horizontal Pod Autoscaler 기능을 적용해보도록 하겠습니다. Horizontal Pod Autoscaler 란 Horizontal Pod Autoscaler는 지정된 CPU 사용률을 기반으로 Replication Controller, Deployment 또는 Replica Set의 Pod 수를 자동으로 조정합니다. Kubernetes에서는 CPU 자원에 대한 사용량을 다음과 같은 식으로 계산하여 Pod을 자동 Scale-out 할 수 있습니다. [CPU example] TargetNumOfPods = ceil(sum(CurrentPodsCPUUtilization) / Target) 주기적으로 Pod의 자원 사용을 체크하고, 특정 시간의 여유를 두고 downscale/upscale이 이루어지는데, 이는 kube-controller-manager가 담당합니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/kubernetes/hpa/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/kubernetes" rel="tag">kubernetes</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/container-orchestration" rel="tag">container orchestration</a></li><li><a href="/tags/hpa" rel="tag">hpa</a></li><li><a href="/tags/horizontal-pod-autoscaler" rel="tag">horizontal pod autoscaler</a></li><li><a href="/tags/autoscale" rel="tag">autoscale</a></li><li><a href="/tags/scale-out" rel="tag">scale out</a></li></ul>

            

        </div></div>
</div>

            
                <div class="fulid-set-12 card mb-30">
    <div class="row card-style-2">
    <div class="col-sm-12 col-xs-12 post-info"><h3 class="post-title">
                <a href="/posts/kubernetes/rolling-update/">[Kubernetes 활용(2/8)] Rolling Update(무중단 배포)</a>
            </h3>

            <h4 class="post-authorName">
                by&nbsp;<a href="/authors/blingeeeee">김빛나</a></h4>

            <p class="post-excerpt">지난 챕터에서는 Kubernetes 환경에서 애플리케이션을 배포하고 접속하는 방법을 알아보았습니다. 그렇다면 이미 배포되어 있는 애플리케이션을 업데이트할 때 중단 없이 처리할 수 있을까요?? 네. 가능합니다! Kubernetes에서는 중단 없이 애플리케이션을 배포할 수 있도록 Rolling Update라는 기능을 지원하고 있습니다. 지난 챕터에서 간단히 나오긴 했지만 다시 한번 자세히 알아봅시다. Rolling Update 란? 서비스 중단 없이 애플리케이션을 업데이트 하기 위해서, Kubernetes에서는 rolling update라는 기능을 지원합니다. 이 기능을 통해서 전체 Pod을 일시에 중단/업데이트 하는 것이 아니라, 한번에 n개씩 Pod을 순차적으로 업데이트할 수 있습니다.
                    </p>

            <p class="btn-link">
                <a href="/posts/kubernetes/rolling-update/">Read more...</a>
            </p>

            
                <ul class="tag"><li><a href="/tags/kubernetes" rel="tag">kubernetes</a></li><li><a href="/tags/container" rel="tag">container</a></li><li><a href="/tags/container-orchestration" rel="tag">container orchestration</a></li><li><a href="/tags/rolling-update" rel="tag">rolling update</a></li></ul>

            

        </div></div>
</div>

            

            
<div class="col-lg-12 text-center">
    <ul class="pagination">
        
            
            <li class="active"><a href="#">1</a></li>
            
        
            
            <li><a href="/tags/container/page/2/">2</a></li>
            
        

        
        <li><a href='/tags/container/page/2/'><i class="fa fa-angle-right" aria-hidden="true"></i></a></li>
        
    </ul>
</div>



        </article>
    </section>
</div>


        <footer class="site-footer">
    <div class="container">

        <ul class="sns">

            <li>
        <a class='social-button' href='https://twitter.com/cloudzlabs' target='_blank' rel='noopener'><i class='fa fa-twitter' aria-hidden='true'></i></a>
    </li><li>
        <a class='social-button' href='https://facebook.com/cloudzlabs' target='_blank' rel='noopener'><i class='fa fa-facebook' aria-hidden='true'></i></a>
    </li><li>
        <a class='social-button' href='https://github.com/cloudzlabs' target='_blank' rel='noopener'><i class='fa fa-github' aria-hidden='true'></i></a>
    </li><li>
        <a class='social-button' href='mailto:withdtlabs@gmail.com' target='_blank' rel='noopener'>
            <i class='fa fa-envelope' aria-hidden='true'></i></a>
    </li>

            

        </ul>

        <span class='copyright'><b>
            
        

         &copy; 2018
        SK 주식회사 C&amp;C <span>Digital Labs</span> All Rights Reserved.
</span></b>


    </div>
</footer>


        <a class="scroll-to-top-btn visible" href="#">
    <i class="fa fa-arrow-up" aria-hidden="true"></i>
</a>
<script src='/assets/js/main.5871befd.js'></script>

<script type="text/javascript">
    
        var baseurl = "http:\/\/tech.cloudz-labs.io\/";
    
</script><script src='/assets/js/common.js'></script><script src='/assets/js/scripts.js'></script><script src='/assets/js/lunr.min.js'></script><script src='/assets/js/auto-complete.js'></script><script src='/assets/js/search.js'></script><script src='/assets/js/clipboard.min.js'></script><script src='/assets/js/mermaid.js'></script></body>

</html>
