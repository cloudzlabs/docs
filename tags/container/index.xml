<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>container on DIGITAL LABS</title>
    <link>http://tech.cloudz-labs.io/tags/container/</link>
    <description>Recent content in container on DIGITAL LABS</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 11 May 2018 17:43:17 +0900</lastBuildDate>
    
	<atom:link href="http://tech.cloudz-labs.io/tags/container/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Docker 시작하기</title>
      <link>http://tech.cloudz-labs.io/posts/docker/docker-start/</link>
      <pubDate>Fri, 11 May 2018 17:43:17 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/docker-start/</guid>
      <description>리눅스의 컨테이너 기술은 굉장히 오래전부터 있던 기술입니다. 그런데 왜 최근에 화두로 떠오르고 있는걸까요? 저는 컨테이너 기술 활성화에 크게 기여한 것이 바로 Docker라고 생각합니다. Docker는 Docker Store(구 Docker Hub)라는 퍼블릭한 레지스트리를 통해 여러 기업들에서 참여하여 이미지를 제공해주고 있지요. 오픈소스 솔루션 중에는 없는 이미지를 찾는게 더 어려운 것 같습니다. 이처럼 Docker 생태계가 잘 되어 있는데 그 생태계를 사용자들로 하여금 굉장히 쉽게 활용할 수 있도록 편의성을 제공해주고 있기 때문에 사용자들은 원하는 솔루션에 대한 이미지를 받아서 컨테이너로 띄우기만 하면 끝입니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(7/8)] Secret</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/secret/</link>
      <pubDate>Fri, 11 May 2018 13:55:54 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/secret/</guid>
      <description>지난 챕터의 ConfigMap에 이어서 이번에는 Secret Object를 보도록 하겠습니다.
Secret 이란? Secret은 비밀번호나 OAuth 토큰값 또는 ssh key 등의 민감한 정보를 유지하기 위해 사용됩니다. 이러한 정보를 Docker 이미지나 Pod에 그대로 정의하기 보다 Secret을 활용하면 더욱 안전하고 유동적으로 사용할 수 있습니다.
Secret 적용하기 Secret 생성 명령어를 통해 생성하기 아래와 같이 kubectl create secret 명령어를 통해 Secret을 생성합니다.
Window OS의 경우 아래 yaml 파일로 Secret을 직접 생성하는 방식으로 사용하세요.
$ kubectl create secret generic db-user-pass --from-literal=user=admin --from-literal=password=1f2d1e2e67df secret &amp;#34;db-user-pass&amp;#34; created 아래와 같이 kubectl get 명령어와 kuberctl describe 명령어를 통해 생성된 Secret을 확인합니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(6/8)] ConfigMap</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/configmap/</link>
      <pubDate>Fri, 11 May 2018 13:55:48 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/configmap/</guid>
      <description>이번에는 Kubernetes에서 제공하는 ConfigMap이라는 Object를 보도록 하겠습니다.
ConfigMap 이란? ConfigMap은 컨테이너 이미지에서 사용하는 환경변수와 같은 세부 정보를 분리하고, 그 환경변수에 대한 값을 외부로 노출 시키지 않고 내부에 존재하는 스토리지에 저장해서 사용하는 방법입니다. 혹시 마이크로서비스 아키텍처에서 사용하는 Spring Cloud Config(Config Server)를 사용한 적이 있다면 동일한 역할을 하는 것인지 하는 생각이 들 수 있는데요. Spring Cloud Config 같은 경우에는 설정 파일 자체를 분리하고 파일에 대한 내용이 변경된다면 자동으로 Refresh 해주는 기능을 가지고 있습니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(5/8)] Ingress</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/ingress/</link>
      <pubDate>Thu, 10 May 2018 18:24:03 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/ingress/</guid>
      <description>Kubernetes에서는 애플리케이션을 외부로 노출하기 위해 Service object를 NodePort로 생성합니다. 그러나 노출 형태가 노드의 IP에 특정 포트(30000-32767)로 제공되기 때문에 호출이 까다롭고 사용자가 서비스로 유입되는 경로도 다양해서 관리가 어려워질 수 있는데요. 이 때, 외부 액세스를 관리하고 서비스를 묶어주는 역할을 하는게 바로 Ingress 입니다.
Ingress 란? 위 그림과 같이 Ingress는 외부 액세스를 관리하고 서비스를 묶어주는 역할을 합니다. Ingress를 만들 때 도메인을 지정할 수 있고 사용자는 그 도메인으로 접속을 하게 되며 도메인 하위의 path 설정을 통해 서비스들을 라우팅할 수 있게 됩니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(4/8)] Mysql DB 연동하기</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/backingservice/</link>
      <pubDate>Tue, 08 May 2018 15:23:03 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/backingservice/</guid>
      <description>지난 챕터에서는 사용한 리소스를 기반으로 애플리케이션의 수를 자동으로 조절할 수 있는 HPA 라는 기능을 적용해 보았습니다. 그렇다면 애플리케이션에 Mysql 또는 Redis 등과 같은 서비스를 연동하고 싶을 땐 어떻게 해야할까요? Kubernetes에서는 애플리케이션에서 필요한 서비스를 Docker Image를 사용하여 바로 구성할 수 있습니다. 물론 대부분이 오픈소스 솔루션에 대한 서비스겠지요. Legacy에 있는 서비스들 역시 연동이 가능하긴 하지만, 여기서는 Docker Image 를 통해 Mysql DB를 구성하고 애플리케이션에 연동해보도록 하겠습니다.
샘플 애플리케이션에 대한 자세한 설명은 Spring의 Accessing data with MySQL 문서를 참고하시기 바랍니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(4/8)] docker build &amp; push</title>
      <link>http://tech.cloudz-labs.io/posts/docker/docker-build-push/</link>
      <pubDate>Fri, 09 Mar 2018 08:23:38 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/docker-build-push/</guid>
      <description>Docker 환경에 Service 및 Application을 구동시키 위한 전체적인 과정은 다음과 같습니다.
graph BT; A[Dockerfile] --|build| B[Images] B --|push| C[Docker Registry] C --|pull| B subgraph Local Docker Instance B --|Run| D[Container] end  지금까지는, Docker Registry(Docker Hub)에 배포되어 있는 있는 Image를 이용해 Container를 구동시켰습니다. 이제부터는 위에서 정리한 과정대로, Dockerfile로 Image를 생성하고 다른 Machine에서 배포된 Image로 Container를 실행시켜 보겠습니다.
본 예제는 About storage drivers에 있는 예제를 참고하여 진행했습니다.
 신규 Image 생성에서 배포까지 Dockerfile 작성 image-build-test 폴더를 생성한 뒤, 다음의 내용이 포함된 Dockerfile을 생성합니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(3/8)] Container는 뭘까?</title>
      <link>http://tech.cloudz-labs.io/posts/docker/what-is-container/</link>
      <pubDate>Fri, 09 Mar 2018 08:22:39 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/what-is-container/</guid>
      <description>Docker는 Application의 배포와 운영을 쉽게 도와주는 &amp;lsquo;Containers as a Service(CaaS) Platform이며, Client-Server Model로 동작하고 있습니다. 여기서 Container란, 운영체제의 커널이 하나의 인스턴스가 아닌, 여러 개의 격리된 인스턴스들을 갖출 수 있도록 하는 서버 가상화 방식입니다. 이러한 인스턴스들은 이를 소유하고 있는 Host Machine과 사용자의 관점에서 바라보면, 실제 서버인 것처럼 보입니다.
가상화(Virtualization) Container는 가상화 방식의 한 종류입니다. 하지만, 흔히 우리가 알고있는 가상화(Virtualization)는 VMWare Workstation과 같은 소프트웨어를 이용해, Linux나 MacOS위에 Windows를 올려서 사용하는 그런 것을 떠올릴 것입니다.</description>
    </item>
    
    <item>
      <title>[Docker 기본(1/8)] Hello Docker!</title>
      <link>http://tech.cloudz-labs.io/posts/docker/hello-docker/</link>
      <pubDate>Thu, 08 Mar 2018 18:47:30 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/docker/hello-docker/</guid>
      <description>Docker란 리눅스의 응용프로그램들을 소프트웨어 Container 안에 배치시키는 일을 자동화하는 오픈 소스 프로젝트로서, Docker 공식 문서에 따르면 Containers as a Service(CaaS) Platform으로 정의하고 있습니다.
Docker는 홈페이지에 Docker의 기능을 아래와 같이 명시 하고 있습니다.
 Docker Container는 일종의 소프트웨어 실행에 필요한 모든 것들을 포함하는 완전한 파일 시스템 안에 감싼다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는 무엇이든 전부 아우른다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(3/8)] HPA(오토스케일링)</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/hpa/</link>
      <pubDate>Thu, 22 Feb 2018 14:41:49 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/hpa/</guid>
      <description>지난 챕터에서는 이미 배포되어 있는 애플리케이션을 무중단으로 업데이트하는 방법에 대해 보았습니다. 이번에는 이어서 애플리케이션을 자동으로 Scale-out 할수 있는 Horizontal Pod Autoscaler 기능을 적용해보도록 하겠습니다.
Horizontal Pod Autoscaler 란 Horizontal Pod Autoscaler는 지정된 CPU 사용률을 기반으로 Replication Controller, Deployment 또는 Replica Set의 Pod 수를 자동으로 조정합니다. Kubernetes에서는 CPU 자원에 대한 사용량을 다음과 같은 식으로 계산하여 Pod을 자동 Scale-out 할 수 있습니다.
[CPU example] TargetNumOfPods = ceil(sum(CurrentPodsCPUUtilization) / Target) 주기적으로 Pod의 자원 사용을 체크하고, 특정 시간의 여유를 두고 downscale/upscale이 이루어지는데, 이는 kube-controller-manager가 담당합니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(2/8)] Rolling Update(무중단 배포)</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/rolling-update/</link>
      <pubDate>Thu, 22 Feb 2018 14:41:42 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/rolling-update/</guid>
      <description>지난 챕터에서는 Kubernetes 환경에서 애플리케이션을 배포하고 접속하는 방법을 알아보았습니다. 그렇다면 이미 배포되어 있는 애플리케이션을 업데이트할 때 중단 없이 처리할 수 있을까요?? 네. 가능합니다! Kubernetes에서는 중단 없이 애플리케이션을 배포할 수 있도록 Rolling Update라는 기능을 지원하고 있습니다. 지난 챕터에서 간단히 나오긴 했지만 다시 한번 자세히 알아봅시다.
Rolling Update 란? 서비스 중단 없이 애플리케이션을 업데이트 하기 위해서, Kubernetes에서는 rolling update라는 기능을 지원합니다. 이 기능을 통해서 전체 Pod을 일시에 중단/업데이트 하는 것이 아니라, 한번에 n개씩 Pod을 순차적으로 업데이트할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[Kubernetes 활용(1/8)] 시작하기</title>
      <link>http://tech.cloudz-labs.io/posts/kubernetes/getting-start/</link>
      <pubDate>Wed, 21 Feb 2018 11:33:28 +0900</pubDate>
      
      <guid>http://tech.cloudz-labs.io/posts/kubernetes/getting-start/</guid>
      <description>언젠가부터 클라우드 열풍이 불어 닥치고 있습니다. 기술의 변화를 보면 IaaS보다는 PaaS나 SaaS를 선호하고, VM에서 직접 컨트롤 하기 보다는 컨테이너, 서버리스 형태의 기술들이 뜨고 있습니다. 저도 그러한 이유로 작년부터 조금씩 회사에서 Kubernetes 스터디를 하고 있네요. 이번 첫번째 챕터에서는 Kubernetes를 처음 접하는 사용자를 위해 Kubernetes 환경에서 애플리케이션을 배포/접속하고 관리하는 기본적인 방법에 대해 보도록 하겠습니다.
시작하기 전에 애플리케이션 배포를 진행하기 전에 이해가 필요한 기본 개념입니다.
Kubernetes  Kubernetes는 2014년 Google이 시작한 프로젝트로, 애플리케이션 컨테이너의 배포, 스케일링, 오퍼레이팅을 자동화 해주는 오픈 소스 플랫폼입니다.</description>
    </item>
    
  </channel>
</rss>